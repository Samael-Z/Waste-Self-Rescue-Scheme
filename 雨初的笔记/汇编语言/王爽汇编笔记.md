![image-20200901105721775](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed@master/image-20200901105721775.png)

+ 根据传送信息的不同，总线从逻辑上又分为3类，地址总线，控制总线和数据总线

+ 8086有 **20** 位地址总线，可以寻址 **1MB** 。

+ 对于8086PC机，在任意时刻，设 `CS` 中的内容为 **N** ， `IP` 中的内容为 **N** ，该8086CPU将从内存地址 **M * 16 + N** 单元开始读取一条指令并执行。

+ 如果想同时修改 `CS、IP` 的内容，可以用 `JMP 段地址：偏移地址` 的指令完成。如

  ```asm
  JMP 2AE3:3
  ```

+ 如果想仅修改 `IP` 的内容，可以使用 `JMP 某一合法寄存器` 来实现。如

  ```asm
  JMP AX ;将IP中的值设置为AX中的值，相当于 `MOV IP, AX`
  ```



## debug使用

+ `R` 可以查看寄存器的值

+ `R 寄存器` 可以修改寄存器的值

+ `d` 完再 `d` 一次可以再查看后面128（0x80）个单位的内存的值

+ 在 `d CS:IP` 后面跟上一个数字，这个数字表示 **结束的地址而不是展示字节的多少！** 。如 `d 1000:0 9`

  ![image-20200906211224632](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed@master/image-20200906211224632.png)

+ `e` 可以改变内存中的值， `e 起始地址 数据 数据 数据`

  ![](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed@master/image-20200906211600374.png)

+ ![image-20200906223936395](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed@master/image-20200906223936395.png)

+ `t` 执行一行语句

+ `r` 查看寄存器，`r 某个寄存器` 可以修改这个寄存器的值

+ `e` 改写内存中内容

+ `d` 查看内存中内容，如果需要以段寄存器中的数据作为段地址来查看，也可以，如 `d DS:0`

+ `u` 查看内存中命令（汇编指令）

+ `a` 改写内存中内容（以汇编指令模式写入）

+ 遇到 `int 21H` 的时候要用 `P` 命令执行。

+ `q` 可以退出 `debug`

+ `g` 指令可以执行到指定位置。如我们想执行到 `CS:0012` 处，则输入 `g 0012` 。这样只有到 `(IP) == 0012H` 得时候才会断下来。

+ 遇到循环的时候使用 `p` 指令可以自动将循环执行完毕，直到 `(cx) == 0` 为止。



## other

+ 8086CPU不支持将数据直接送入寄存器的操作， `mov ds, 1000H` 这条指令是非法的。想要将 `1000H` 送入DS，需要使用一个寄存器进行中转，先将 `1000H` 送入一个一般的寄存器，再将这个寄存器中的内容送入DS

+ 8086的入栈和出栈操作都是以 **字** 为单位进行的

+ 栈的段寄存器是 `ss` ，栈顶是 `ss:sp` ，栈底是 `ss:bp`

+ 压栈的时候，栈顶从 **高地址向低地址方向** 增长

+ 栈空的时候 `SS:SP` 指向栈空间最高地址单元的下一个单元，如果把 `10000H-1000FH` 这段空间当作栈，初始状态栈是空的的时候 `SS:SP` = `1000:0010`

  ![image-20200913174004956](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed@master/image-20200913174004956.png)

+  用 `xor ax, ax` 或者 `sub ax, ax` 而不是 `mov ax, 0` 来将 `ax` 清零的主要原因是前两个（在32位下）的机器码是3个字节，而 `mov ax,0` 的机器码是4个字节。

  ![image-20200913175029069](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed@master/image-20200913175029069.png)

+ 执行 `push` 时，CPU要进行两步操作：先改变 `SP` ，后向 `SS:SP` 处传送。执行 `POP` 时，CPU先读取 `SS:SP` 处的数据，然后改变 `sp` 。

+ 一个栈段最大64K（在8086CPU环境下），因为栈顶的变化范围是 `0-FFFFH` 。如果一直压栈的话栈顶将环绕，覆盖原来栈中的内容

+ 数据段 `DS` ，代码段 `CS` ，栈段 `SS` 。

  ![image-20200913182226722](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed@master/image-20200913182226722.png)

+ `debug` 的 `T` 指令在修改寄存器 `SS` 的指令是，下一条指令也紧接着被执行。如 `MOV SS,AX` `POP SS` `MOV SS,[0]` 这种指令在使用 `T` 单步执行的时候其下一行指令都会同时被执行。这跟中断机制有关，当前只需知道这一点即可。

+ `XX segment` 和 `XX ends` 用来定义一个段。

  ![image-20200913190829584](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed@master/image-20200913190829584.png)

+ `end` 是一个汇编程序的结束标记，编译器在编译汇编程序的时候，如果遇到了伪指令 `end` 则结束对原文件的编译。所以我们写程序的时候如果程序写完了，要在结尾处加上伪指令 `end` ，否则编译器在编译程序的时候不知道程序在何处结束。

+ ![image-20200913191140672](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed@master/image-20200913191140672.png)

+ 程序返回：在汇编中为了让程序返回需要在末尾加上这两条汇编代码

  ```asm
  MOV AX,4C00H
  INT 21H
  ```

  >INT 21H 是调用了系统中断
  >MOV AX,4C00H
  >其实起作用的就是 AH=4CH，意思就是调用 INT 21H 的 4CH 号中断，该中断就是安全退出程序。
  >其实这句等价于
  >MOV AH,4CH
  >INT 21H

+ 在使用masm编译的时候我们提供一个输入，最多可以获得3个输出：目标文件（.obj）列表文件（.lst）交叉引用文件（.crf）。其中除了 `.obj` 文件，另外两个是中间结果，可以让编译器忽略对他们的生成。

+ 快速生成exe的方法：

  ```asm
  masm 1;
  link 1;
  ```

+ 程序加载后， `ds` 中存放着程序所在内存区的段地址，这个内存区的前256个字节中存放的是 `PSP` ，DOS用PSP来和被加载程序进行通信。

+ PSP前两个字节的内容是 `CD 20` ，在运行debug后输入 `d ds:0` 即可看到

  ![image-20200913201022108](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed@master/image-20200913201022108.png)





+ `loop` 指令可以将指定的代码重复运行 `[cx]` 次。

  ![image-20200913201809933](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed@master/image-20200913201809933.png)

+ 在汇编语言中，标号代表一个地址，上图中的 `s` 其实就标识了一个地址。这个地址处有一条指令： `add ax, ax`

+ CPU在执行 `LOOP` 的时候，要进行两步操作：
  1. `cx -- `
  2. 判断CX中的值，如果不为0则转到S标识处执行，为0则执行下一行指令。（比如CX=1，先减一得0，则跳出循环继续执行下一条指令。）
+ **在汇编源程序中，数据不能以字母开头，所以要在前面加0。** 如 `mov ax,0ffffh` 。
+ 写 `asm` 代码的时候如果需要表示某一偏移地址的东西，可以使用 `mov al,ds:[0]` 这样的代码。要指定段寄存器，不能直接使用 `mov al, [0]` ，否则会被编译成 `mov al,0` 。（ `mov ax, [bx]` 这样的代码就不用加段寄存器）