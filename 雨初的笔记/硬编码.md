+ OD里面想要改某个指令的硬编码按 `ctrl + E`
+ 在32位保护模式下，各种段寄存器的基址都是0，因为根本不需要再像16位汇编那样根据基址加偏移来定位了

## 70~7F JCC指令（后跟一个有符号数字）

+ 70（ `JO` ）后面存储的数字是 **有符号** 的，如果是 **0~7F** 是 **往下跳** ，如果是超过 **7F** 了，因为这个数字是 **有符号的** ，所以其实是一个负数，会 **往回跳** 。

  > 如果条件成立，跳转到 **当前指令地址 +  当前指令长度 + Ib** （ **Ib** 是指一个 **一个BYTE大小的立即数** ）

```asm
0x70  	JO	
0x71	JNO	
0x72	JB/JNAE/JC	
0x73	JNB/JAE/JNC	
0x74	JZ/JE	
0x75	JNZ/JNE	
0x76	JBE/JNA	
0x77	JNBE/JA	
0x78	JS	
0x79	JNS	
0x7A	JP/JPE	
0x7B	JNP/JPO	
0x7C	JL/JNGE	
0x7D	JNL/JGE	
0x7E	JLE/JNG	
0x7F	JNLE/JG	
```

## 0x0F 0x80 ~ 0x0F 0x8F

+ 条件跳转，后跟四个字节立即数的偏移(有符号)，共五个字节。

  > 如果条件成立，跳转到 **当前指令地址 + 当前指令长度 + Id** （**Id** 是指一个**一个DWORD大小的立即数**）
  >
  > 最大值：向前跳7FFFFFFFF，向后跳80000000			

```asm
0x0F 0x80  		JO	
0x0F 0x81		JNO	
0x0F 0x82		JB/JNAE/JC	
0x0F 0x83		JNB/JAE/JNC	
0x0F 0x84		JZ/JE	
0x0F 0x85		JNZ/JNE	
0x0F 0x86		JBE/JNA	
0x0F 0x87		JNBE/JA	
0x0F 0x88		JS	
0x0F 0x89		JNS	
0x0F 0x8A		JP/JPE	
0x0F 0x8B		JNP/JPO	
0x0F 0x8C		JL/JNGE	
0x0F 0x8D		JNL/JGE	
0x0F 0x8E		JLE/JNG	
0x0F 0x8F		JNLE/JG	
```

