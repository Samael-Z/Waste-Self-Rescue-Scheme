+ 因为如果一个程序里面有 `RWX` 的区域会遭到怀疑，所以我们可以采用先使用 `VirtualAlloc` 其改为 `RW` 属性，将代码复制过去后再通过 `VirtualAlloc` 将其改为 `X` 属性，这样就不会出现 `RWX` 的代码片段了。

+ ![image-20210306192606871](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210306192606871.png)

  X64dbg可以这样查找内存中的东西。

+ 也可以把 `shellcode` 藏在资源表中。用 `FindResourse` 找到相应的图标

  ![image-20210306193315062](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210306193315062.png)

  ```C
  HRSRC res = FindResourse(NULL, MAKEINTRESOURCE(资源名), RT_RCDATA)
  ```

  然后通过 `LoadResourse` 将图标加载到内存中

  ![](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210306193519471.png)

  ```c
  HGLOBAL resHandle = LoadResource(NULL, res);
  ```

  再通过 `LockResourse` 将其锁定在内存中（这一步不太明白，为什么要锁定）

  ```c
  unsigned char * payload = (char *) LockResource(resHandle);
  ```

  `payload` 变量指向的地方就是我们所需的 `shellcode` 。

+ 可以使用VS自带的base64编码工具来编码我们的 `shellcode` 。

  ![image-20210306195804376](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210306195804376.png)

+ 可以用 `CryptStringToBinary` 这个win32api来进行base64解码。不用自己写base64解码函数

  ![image-20210306195954624](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210306195954624.png)

  ```c
  #include <Wincrypt.h>
  #pragma comment (lib, "Crypt32.lib")
  
  int DecodeBase64( const BYTE * src, unsigned int srcLen, char * dst, unsigned int dstLen )
  ...
      fRet = CryptStringToBinary( (LPCSTR) src, srcLen, CRYPT_STRING_BASE64, (BYTE * )dst, &outLen, NULL, NULL);
  ...
  ```

+ base64过不了杀软，自己写加密最好




