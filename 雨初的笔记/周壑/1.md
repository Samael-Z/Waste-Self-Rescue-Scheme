+ 在微软vs里面如果要写64位的程序，是不支持内联汇编 `__asm` 的。如果要内嵌汇编，需要另外写一个文件。

  ![image-20210306123345094](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210306123345094.png)

+ `rflag` 的高32位全为0，只是为了扩展而扩展成64位。原来32位都还有很多位没有用到

+ ![image-20210306124925842](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210306124925842.png)

  64位系统 ```00007fff`ffffffff~ff8000`00000000``` 的内存地址是没有使用的。其上面是内核空间，下面是用户空间，这样把内核空间和用户空间做一个隔离。

+ 对32位寄存器的写操作，如 `mov eax, 1` 会将相应64位寄存器的 **高32位清零** 。不只是写操作，运算的时候也会影响。比如 `sub eax, 1`  ，也会将64位寄存器的高32位清零。

  + 由于64位汇编的这个特性，我们想要清空 `rax` 的时候也可以使用32位汇编时使用的方法 `xor eax, eax` 。也可以将整个rax寄存器清零。而如果用 `xor rax, rax` 这条指令的话其硬编码会多出一个字节。

    ![image-20210306130230308](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210306130230308.png)

    如果我们要返回一个64位的0，那么编译器生成的代码会是 `xor eax, eax` 。所以看到这条指令的时候不一定代表返回的这个就是一个32位的变量。

    ![image-20210306130618357](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210306130618357.png)

  + 只有操作32位寄存器的时候会将整个64位的寄存器清零。在操作16位的时候并不会有相同的效果。如 `mov ax, 1` 或者 `mov al, 1` 之类的指令并不会影响到 `rax` 其他位上的值。

  + 汇编上看一样的指令硬编码上看不一定一样

    ![image-20210306131453343](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210306131453343.png)

    这个使用到了符号扩展

+ `push` 只能压4个字节，压8个字节的指令不存在，不可以一次压8个字节。如果想要一次压8个字节可以这样

  ![image-20210306132117833](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210306132117833.png)

  先在 `rax` 中倒个手再压到栈里面去。

+ `mov` 指令如果想要 `mov ptr qword ...` 的话，也最多只能移动4个字节。事实上除了直接对寄存器操作，很多操作都不支持8个字节的操作。

+ ![image-20210306132229370](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210306132229370.png)

+ 64位有特别的 `nop`

  ![image-20210306133100972](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210306133100972.png)

  应该是为了内存对齐，直接当其为 `nop` 即可。

+ 在 **正负偏移2GB** 之内的时候， `mov rax, qword ptr ds:[]` 这样的指令后面跟的是一个 **有符号的32位的相对偏移** ，是相对当前指令位置的偏移。而如果正负偏移大于2GB的话，则跟的是一个64位的绝对地址。使用的时候比如如果想读别人的模块的地址，因为距离比较远，所以一半会用到的是第二种，也就是长地址。

  ![image-20210306133701447](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210306133701447.png)

+ `cs` ， `ds` 在x64下的基址都是0，段，保护模式，在x64下已经基本上被废弃了。

+ `EB` 是短跳，后面跟一个字节，比如 `EB FE` 就是跳到自身，是一条死循环的代码。 `E9` 后面跟4个字节，也是相对偏移。

+ `ff25 00000000` 后面跟着的是一个相对偏移（带符号），`jmp` 跳到的地址是后面跟着的这个相对偏移里面存放的那个地址。因此如果我们在挂钩子的时候想让程序跳转到某个地方，可以 `ff25 0000000` 然后在后面写上我们想要跳转到的内存地址。这样可以成功跳转到我们想要跳转到的地址。

+ vs有一个这样的bug

  ![image-20210306143523001](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210306143523001.png)

  因此在使用大于4个字节的硬编码的时候要格外小心。

+ 在挂钩子的时候因为模块之间的距离一般都会大于2GB，因此不会直接使用 `JMP 偏移` 这种方式挂钩子。使用

  ```asm
  mov rax, 绝对地址
  jmp rax
  ```

  这种方式比较常见。或者

  ```asm
  push rax
  ret
  ```

  也可以。

+ 为了防止影响到原来的 `rax` ，在钩子执行完了之后返回的时候还能继续原来的进程，可以先把 `rax` 入栈，回来之后再出栈

  ```asm
  push rax
  mov rax, 绝对地址
  jmp rax
  pop rax ;（这条在钩子函数里面执行）
  ```

+ 在x64里面没有 `pushad` 指令，或者 `pushaq` 之类的。如果想要保存寄存器，要把所有的寄存器都 `push` 一遍，从 `rax` push到 `r15` 。

+ 返回的时候可以这样

  ![image-20210306144518058](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210306144518058.png)

  通过 `ret` 来进行返回。

  ![image-20210306145341640](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210306145341640.png)

  这样更短



## 64位调用约定

+ https://devblogs.microsoft.com/oldnewthing/?p=41053
+ x64只有一种调用约定， `__stdcall` 、 `__cdecl` 、 `__fastcall` 会被编译器忽略。
+ 调用方分配和清理参数所用的栈空间（外平栈）。编译器生成的代码中基本上不会存在 `ret 8` 这样的指令。
+ 前4个参数使用 `rcx` 、 `rdx` 、 `r8` 、 `r9` 传递。