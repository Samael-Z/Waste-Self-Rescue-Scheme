+ 开启核心转储，高级系统属性

  ![image-20210315170427769](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210315170427769.png)

  转储文件要改一下，不然一开机windows会自动删除相应文件。

+ `legacy` 模式是给32位CPU用的，其内核也是32位的。

  而 `ia-32e` 模式内核也是64位的，只是用户可以跑32位或者64位的程序。在64位系统下不支持任务切换，没有tss。

  ![image-20210315171041946](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210315171041946.png)

+ MSR中C0000080H处，第8位表示是否为ia-32e模式。如果是1说明其是ia-32e模式。

+ 段描述符还是64位的，因此如果想要描述基址的话还是32位的基址，这叫做强制平坦。不再描述基址和界限，在64位下基址永远是0，有效地址永远是最大的。只用来描述是代码段还是数据段以及DPL

+ ![image-20210315202505186](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210315202505186.png)

  l位很重要，描述了这个代码是处于32位模式下还是64位模式下。

+ ![image-20210315203138006](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210315203138006.png)

  `dg` 是显示段选择子

+ `cs = 23` 说明是32位程序（在3环下），`cs = 33` 说明是64位程序

+ ![image-20210315203436272](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210315203436272.png)

  代码段、数据段仍使用64位描述符，但TSS段扩展到128位，不在用来进行任务切换，主要用来保存一堆rsp备用指针。

  ![image-20210315203807654](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210315203807654.png)

+ ![image-20210315210738836](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210315210738836.png)

  FSBASE和GSBASE两个寄存器用来存放FS和GS的基址（msr里面+c0000100和+c0000101）

+ 进入内核的时候使用 `swapgs` 把gs段的基址和内核gs基址切换一下。

+ ![image-20210315212642429](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210315212642429.png)

+  ~~在进内核之前会将 `rsp` 和 `r14` 进行切换，在~~
+ 32位程序进内核的时候先通过一个长跳 `jmp far 0033:xxxxxxxx` 切换cs到64位段33，然后在这里面进行一些32位程序内容的保存，栈的保存之类的，在转入64位模式之后进入内核。（64位通过 `syscall` 进入内核）。
  + 在 `ntdll` 里面转为64位，进行一系列准备工作之后跟64位程序一样通过 `syscall` 系统调用进入内核。
+ 在我们写代码的时候，也可以像32位下一样重写三环API，64位下运行的32位程序在三环通过 `jmp 0033:xxxxxxxx` 进入33段，进入64位模式，我们也可以通过这样的方法让程序进入64位。我们可以往里面塞一段64位代码通过这样执行。这样可以迷惑调试器和反汇编器。
+ 64位下没有类似32位下的长跳转 `jmp far xxxx:xxxxxxxx` ，如果需要进行跨段跳转，要使用 `jmp far tword ptr ds:[rax]` ，其硬编码是 `48 ff 28` ，rax里面存一个十个字节的数据，前8个字节指示要跳转到的地址（32位），后2个字节指示段选择子。将其设置为22可以回到32位下。