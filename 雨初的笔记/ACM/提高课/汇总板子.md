[toc]

# DP

## 数字三角形模型

### 摘花生

### 方格取数

+ ![image-20211125095513699](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211125095513699.png)
+ ![image-20211125095558545](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211125095558545.png)

+ `f[i1, j1, i2, j2]` 表示所有从 `(1, 1)` 分别走到 `(i1, j1)` ， `(i2, j2)` 的路径的最大值。

+ 只有在 `i1 + j1 == i2 + j2` 时，两条路径的格子才可能重合。这里可以将状态再优化一维，用 `f[k, i1, i2]` 表示所有从 `(1, 1)` 走到 `(i1, k - i1)` 和 `(i2, k - i2)` 的路径的最大值。

+ 其状态划分如下

  ![image-20210712190345299](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master/image-20210712190345299.png)
  
  ```cpp
  #include <iostream>
  #include <stdio.h>
  
  using namespace std;
  
  const int N = 10010;
  int f[N][N], w[N][N];
  
  int main()
  {
      int T;
      cin >> T;
      while (T -- )
      {
          int n, m;
          cin >> n >> m;
          for (int i = 1; i <= n; i ++ ) 
              for (int j = 1; j <= m; j ++ ) 
                  cin >> w[i][j];
  
          for (int i = 1; i <= n; i ++ )
              for (int j = 1; j <= m; j ++ )  
                  f[i][j] = max(f[i - 1][j], f[i][j - 1]) + w[i][j];
  
          cout << f[n][m] << endl;
      }
  
      return 0;
  }
  ```

### 传纸条

+ ![image-20211125095805051](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211125095805051.png)

  **输出格式**

  输出一个整数，表示两条路径上取得的最大的和。

+ 这道题其实可以使用和上一题方格取数一模一样的思想来做。做法的正确性可以得到证明 [证明链接](https://www.acwing.com/solution/content/12389/) 。其中可以知道如果两条路线有交叉，那么一定可以将在上面的那条路线和在下面的路线进行交换得到两条不交叉的路线

  ![交点.png](https://cdn.acwing.com/media/article/image/2020/04/29/37263_da1e186e8a-交点.png)

  ![交点2.png](https://cdn.acwing.com/media/article/image/2020/04/29/37263_609a4e9e8a-%E4%BA%A4%E7%82%B9%E7%AD%89%E6%95%88%E6%9B%BF%E6%8D%A2.png)

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 110;
  
  int f[N][N][N];
  int w[N][N];
  
  int main()
  {
      int n;
      cin >> n;
  
      int a, b, c;
      while (cin >> a >> b >> c, a) w[a][b] = c;
  
      for (int k = 2; k <= n + n; k ++ )
      {
          for (int i1 = 1; i1 <= n; i1 ++ )
          {
              for (int i2 = 1; i2 <= n; i2 ++ )
              {
                  int j1 = k - i1, j2 = k - i2;
  
                  if (j1 <= 0 || j2 <= 0 || j1 > n || j2 > n)
                      continue;
  
                  int t = w[i1][j1];
                  if (i1 != i2) t += w[i2][j2];
  
                  int &x = f[k][i1][i2];
                  x = max(x, f[k - 1][i1][i2] + t);
                  x = max(x, f[k - 1][i1 - 1][i2 - 1] + t);
                  x = max(x, f[k - 1][i1 - 1][i2] + t);
                  x = max(x, f[k - 1][i1][i2 - 1] + t);
              }
          }
      }
  
      cout << f[n + n][n][n];
  
      return 0;
  }
  ```

  

## 最长上升子序列模型

### 怪盗基德的滑翔翼（LIS）

### 登山

+ ![image-20211125100131823](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211125100131823.png)

+ 这道题和怪盗基德那道题非常类似，但是并不完全一样。这道题抽象出来是说走的路线只能是先上升然后下降，像 `^` 这样。要求出来走的路线的长度的最大值。

+ 可以按照以 `a[0]、a[1]、a[2] ... a[n]` 为最高点的情况来进行划分和计算。

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  
  using namespace std;
  
  const int N = 1010;
  int a[N];
  int f[N];
  int rf[N];
  
  int main()
  {
      int n;
      cin >> n;
      for (int i = 1; i <= n; i ++ ) cin >> a[i];
      
      
      // 先求一遍正向的LIS
      for (int i = 1; i <= n; i ++ ) 
      {
          f[i] = 1;
          for (int j = 1; j < i; j ++ ) 
              if (a[i] > a[j])
                  f[i] = max(f[i], f[j] + 1);
      }
      
      // 求一遍反向的LIS
      for (int i = n; i >= 1; i -- )
      {
          rf[i] = 1;
          for (int j = n; j > i; j -- )
              if (a[i] > a[j])
                  rf[i] = max(rf[i], rf[j] + 1);
      }
      
      // 遍历一遍
      int res = 0;
      for (int i = 1; i <= n; i ++ )
      {
          int t = f[i] + rf[i] - 1;
          res = max(t, res);
      }
      
      cout << res << endl;
      
      return 0;
  }
  ```

### 导弹防御系统

+ ![image-20211125100253427](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211125100253427.png)

+ 这道题和前面那道题不一样。前面那道题可以贪心，但是这道题不可以，并没有很巧妙的方法来解决这道题，因此只有爆搜。

+ 这里可以直接使用爆搜 `dfs` 的方法来解决问题。找到应该插入到哪个序列中或者应该新开一个序列的方法和前一题类似，但是这里要注意， 因为这里是一个外部搜索，因此 `dfs ` 的时候应该先保存状态再进行 `dfs` ，在完事之后还要恢复到原来的状态。

  ```cpp
  #include <iostream>
  #include <cstring>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 110;
  int up[N], down[N], w[N];
  int n;
  int ans;
  
  void dfs(int u, int su, int sd)
  {
      if (su + sd >= ans) return;
      
      if (u == n)
      {
          ans = su + sd;
          return;
      }
      
      // 在上升的列表中寻找
      int k = 0;
      // 如果不能加入到当前这个序列后面，而且后面还有没遍历完的序列
      while (k < su && w[u] <= up[k]) k ++ ;
      // 如果插入到了当前的一个序列中
      if (k < su)
      {
          // 保存现场
          int t = up[k];
          up[k] = w[u];
          
          dfs(u + 1, su, sd);
          
          // 恢复现场
          up[k] = t;
      }
      else
      {
          up[k] = w[u];
          dfs(u + 1, su + 1, sd);
      }
      
      // 在下降的序列中寻找
      k = 0;
      while (k < sd && w[u] >= down[k]) k ++ ;
      if (k < sd)
      {
          int t = down[k];
          down[k] = w[u];
          
          dfs(u + 1, su, sd);
          
          down[k] = t;
      }
      else
      {
          down[k] = w[u];
          dfs(u + 1, su, sd + 1);
      }
  }
  
  int main()
  {
      while (cin >> n, n)
      {
          for (int i = 0; i < n; i ++ ) cin >> w[i];
          
          ans = n;
          dfs(0, 0, 0);
          
          cout << ans << endl;
      }
      
      return 0;
  }
  ```

  

### 最长公共上升子序列

+ 

## 背包模型

### 装箱问题

+ 这道题第一眼看到很想搜，就写了个dfs

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <math.h>
  #include <limits.h>
  
  using namespace std;
  
  const int N = 60;
  
  int v, n;
  int w[N];
  int res = INT_MAX;
  
  void dfs(int u, int left)
  {
      if (u == n)
      {
          res = min(res, left);
          return;
      }
      
      dfs(u + 1, left);
      if (left >= w[u]) dfs(u + 1, left - w[u]);
  }
  
  int main()
  {
      cin >> v >> n;
      
      for (int i = 0; i < n; i ++ ) cin >> w[i];
      
      // 从第0个物品开始，剩余v
      dfs(0, v);
      
      cout << res << endl;
      
      return 0;
  }
  ```

+ 如果按照这里用01背包的思想来求解的话，可以把体积当成价值来求。如果能够装下的体积最大的话那么剩下的体积一定最小，答案是正确的。代码如下

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <math.h>
  #include <limits.h>
  
  using namespace std;
  
  const int N = 20010;
  int f[N];
  
  int main()
  {
      int total, n;
      cin >> total >> n;
      
      for (int i = 1; i <= n; i ++ ) 
      {
          int v;
          cin >> v;
          for (int j = total; j >= v; j -- )
          {
              f[j] = max(f[j], f[j - v] + v);
          }
      }
      
      cout << total - f[total];
      
      return 0;
  }
  ```

+ dfs用了70ms，dp是13ms。

### 宠物小精灵之收服 

+ 这道题首先用最直观的思想来想。题目中给了两个类似背包容量的值

  1. 精灵球的数量
  2. 皮卡丘的生命值

+ 这里我们可以将 `dp`  数组设置为 

  + `i` ：在前i个小精灵中选择
  + `j` ：所用的精灵球数量小于 `j` 
  + `z` ：总共消耗的体力值小于 `z` 

+ `dp[i][j][z]` 表示从前 `i` 个小精灵中选择，球的总数小于 `j` ，消耗的体力值小于 `z` 的情况下能捕获的小精灵的最大值。

+ 那么可以把状态分为两种情况

  1. 不抓第 `i` 个小精灵， `dp[i][j][z] = d[i - 1][j][z]` 。
  2. 抓第 `i` 个小精灵 `dp[i][j][z] = dp[i - 1][j - v1[i]][z - v2[i]] + 1` 。

+ 代码如下

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 1010, M = 110;
  
  int n, m, k;
  int v1[N], v2[N];
  
  int dp[N][N][N];
  
  int main()
  {
      cin >> n >> m >> k;
      
      for (int i = 1; i <= k; i ++ ) cin >> v1[i] >> v2[i];
      
      for (int i = 1; i <= k; i ++ )
          for (int j = 0; j <= n; j ++ )
              for (int z = 0; z <= m - 1; z ++ ) // 要小于m-1才能被抓
              {
                  dp[i][j][z] = dp[i - 1][j][z];
                  if (j >= v1[i] && z >= v2[i])
                      dp[i][j][z] = max(dp[i][j][z], dp[i - 1][j - v1[i]][z - v2[i]] + 1);
              }
              
      cout << dp[k][n][m - 1] << " ";
      
      // 可以找到和最终结果相同的情况下最少的z，那么剩下的就是m-这个数字
      int k1 = m - 1;
      while (k1 > 0 && dp[k][n][k1 - 1] == dp[k][n][m - 1])
          k1 -- ;
          
      cout << m - k1 << endl;
      
      return 0;
  }
  ```

  这个是A不过的，因为

  ![image-20210729163636547](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master//image-20210729163636547.png)

  数组实在是太大了。

+ 因此我们要进行优化。很容易想到要像01背包问题那样将 `dp` 数组的维数降低。非常简单，直接删掉第一维，然后把后两层 `for` 改为从大到小遍历就可以了。AC代码如下

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 1010, M = 110;
  
  int n, m, k;
  int v1[N], v2[N];
  
  int dp[1001][501];
  
  int main()
  {
      cin >> n >> m >> k;
      
      for (int i = 1; i <= k; i ++ ) cin >> v1[i] >> v2[i];
      
      for (int i = 1; i <= k; i ++ )
          for (int j = n; j >= v1[i]; j -- )
              for (int z = m - 1; z >= v2[i]; z -- ) // 要小于m-1才能被抓
                  dp[j][z] = max(dp[j][z], dp[j - v1[i]][z - v2[i]] + 1);
    
      cout << dp[n][m - 1] << " ";
      
      // 可以找到和最终结果相同的情况下最少的z，那么剩下的就是m-这个数字
      int k1 = m - 1;
      while (k1 > 0 && dp[n][k1 - 1] == dp[n][m - 1])
          k1 -- ;
          
      cout << m - k1 << endl;
      
      return 0;
  }
  ```


### 512货币系统

+ `f[i][j]` 表示从前 `i` 中货币中选，能否表示出 `j` 这个数字。
+ 这里直接做一遍完全背包即可。可以把这个背包的容量设为货币的面额的最大值。然后每次遍历 `i` 的时候判断 `f[i][j]` 是否为 `true` 。如果为 `false` 说明这种货币不能被前面的货币的组合表示出来。 `res ++ ` 。如果为 `true` 说明这种货币可以被前面的货币的组合表示出来，不用选。

### 多重背包Ⅲ（单调队列优化）

+ 

### 二维费用的背包问题

+ 和普通的01背包思路非常类似。 `f[i][j][k]` 表示的是从前 `i` 个物品选，体积最大 `j` ，容积最大 `k` 能选择的最大的价值。

+ 朴素做法如下

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 1010, M = 110;
  int v[N], m[N], w[N];
  int f[N][M][M]; // 从前i，容积不超过j，重量不超过k
  
  int main()
  {
      int n, V, W;
      cin >> n >> V >> W;
      
      for (int i = 1; i <= n; i ++ ) cin >> v[i] >> m[i] >> w[i];
      
      for (int i = 1; i <= n; i ++ ) 
      {
          for (int j = 0; j <= V; j ++ )  
          {
              for (int k = 0; k <= W; k ++ ) 
              {
                  f[i][j][k] = f[i - 1][j][k];
                  if (j >= v[i] && k >= m[i])
                      f[i][j][k] = max(f[i][j][k], f[i - 1][j - v[i]][k - m[i]] + w[i]);
              }
          }
      }
  
      cout << f[n][V][W];
      
      return 0;
  }
  ```

+ 同样也可以将第一维压缩，如下

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 1010, M = 110;
  int v[N], m[N], w[N];
  int f[M][M]; // 从前i，容积不超过j，重量不超过k
  
  int main()
  {
      int n, V, W;
      cin >> n >> V >> W;
      
      for (int i = 1; i <= n; i ++ ) cin >> v[i] >> m[i] >> w[i];
      
      for (int i = 1; i <= n; i ++ ) 
              for (int j = V; j >= v[i]; j -- )
              for (int k = W; k >= m[i]; k -- )
                      f[j][k] = max(f[j][k], f[j - v[i]][k - m[i]] + w[i]);
  
      cout << f[V][W];
      
      return 0;
  }
  ```


### 有依赖的背包问题

+ 

## 状态机模型

### 股票买卖Ⅳ

+ ![image-20211127195228345](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127195228345.png)

+ ![cb8092d74acad480814865d74231b98.png](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed/7416_9af46f5a07-cb8092d74acad480814865d74231b98.png)

  ```cpp
  // f[i][j][k]表示第i天，已经进行了j-1次买入交易
  // 当前可以进行第j次交易，也可以不进行。
  
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 1E5 + 10, M = 110;
  int w[N];
  int f[N][M][2];
  int n, k;
  
  int main()
  {
      cin >> n >> k;
  
      for (int i = 1; i <= n; i ++ ) cin >> w[i];
  
      memset(f, -0x3f, sizeof f);
  
      for (int i = 0; i <= n; i ++ ) f[i][0][0] = 0;
  
      for (int i = 1; i <= n; i ++ ) 
      {
          for (int j = 1; j <= k; j ++ )
          {
              f[i][j][0] = max(f[i - 1][j][0], f[i - 1][j][1] + w[i]);
              f[i][j][1] = max(f[i - 1][j][1], f[i - 1][j - 1][0] - w[i]);
          }
      }
  
      int res = 0;
      for (int i = 0; i <= k; i ++ ) res = max(res, f[n][i][0]);
  
      cout << res << endl;
  
      return 0;
  }
  ```

  

## 状压DP

### 小国王

+ ![image-20211127195258438](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127195258438.png)

+ 这道题和蒙德里安的梦想没有很大区别。

+ https://www.acwing.com/solution/content/10007/ 这篇题解写得很好

  ```cpp
  // f[i][j][k]表示只摆了前i行，当前摆了j个国王，第i行的状态为k
  
  #include <string.h>
  #include <stdio.h>
  #include <algorithm>
  #include <vector>
  #include <iostream>
  
  using namespace std;
  
  typedef long long ll;
  #define pb push_back
  
  const int N = (1 << 10) + 20;
  vector<int> state, head[N]; // state用来预处理合法状态，head[a]用来预处理可以转移到的状态
  int n, k;
  ll f[12][110][N];
  int cnt[N];
  
  // 检查有没有出现相邻的两个1
  bool check(int x)
  {
      if (x & x >> 1) return false;
      return true;
  }
  
  int count(int x)
  {
      int res = 0;
      while (x)
      {
          res += (x & 1);
          x >>= 1;
      }
      
      return res;
  }
  
  int main()
  {
      cin >> n >> k;
      
      // 第一步，预处理state
      for (int i = 0; i < 1 << n; i ++ )
          if (check(i))
          {
              state.pb(i);
              cnt[i] = count(i);
          }
          
      // 第二步，预处理每个集合可以转移到的状态
      for (int i = 0; i < state.size(); i ++ ) 
          for (int j = 0; j < state.size(); j ++ ) 
          {
              int a = state[i], b = state[j];
              if ((a & b) == 0 && check(a | b))
                  head[i].pb(j);
          }
          
      f[0][0][0] = 1;
      for (int i = 1; i <= n + 1; i ++ )
          for (int j = 0; j <= k; j ++ ) 
              for (int a = 0; a < state.size(); a ++ ) 
                  for (int b = 0; b < head[a].size(); b ++ )
                  {
                      int c = cnt[state[a]];
                      if (j >= c)
                          f[i][j][a] += f[i - 1][j - c][head[a][b]];
                  }
                  
      ll res = 0;
      for (int i = 0; i < (1 << n); i ++ ) res += f[n][k][i];
      cout << res << endl;
      //cout << f[n + 1][k][0];
      
      return 0;
  }
  ```

## 区间DP

## 数位DP

1. 数位DP题目基本上都是求 `[l~r]` 区间中满足某一种性质的数的个数。其技巧基本上都是利用前缀和的思想。 `[x, y] => f(y) - f(x - 1)` 。

2. 在做数位DP的时候，要用树的方法来思考解答的方法。

### 度的数量

+ ![image-20211127195437181](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127195437181.png)

  ```cpp
  #include <bits/stdc++.h>
  
  using namespace std;
  
  typedef vector<int> vi;
  #define pb push_back
  
  const int N = 35;
  int K, B;
  int f[N][N];
  
  void init()
  {
      for (int i = 0; i <= N; i ++ ) 
          for (int j = 0; j <= i; j ++ ) 
              if (!j) f[i][j] = 1;
              else f[i][j] = f[i - 1][j - 1] + f[i - 1][j];
  }
  
  int dp(int n)
  {
      if (!n) return 0;
      
      vi v;
      
      while (n)
      {
          v.pb(n % B);
          n /= B;
      }
      
      int res = 0;
      int last = 0;
      
      for (int i = v.size() - 1; i >= 0; i -- ) 
      {
          int x = v[i];
          if (x)
          {
              res += f[i][K - last];
              if (x > 1)
              {
                  if (K - last - 1 >= 0) res += f[i][K - last - 1];
                  break;
              }
              else
              {
                  last ++ ;
                  if (last > K) break;
              }
          }
          
          if (!i && last == K)
          {
              res ++ ;
              break;
          }
      }
      
      return res;
  }
  
  int main()
  {
      init();
      
      int l, r;
      cin >> l >> r >> K >> B;
      
      cout << dp(r) - dp(l - 1) << endl;
      
      return 0;
  }
  ```

  

## 单调队列优化DP

### 修剪草坪

+ 这道题中dp数组 `f[i]` 表示从前 `i` 头牛中选择的所有方案的最大值。

+ 那么 `f[i]` 可以分成选择第 `i` 头牛和不选择第 `i` 头牛。

  1. 不选择第 `i` 头牛 `f[i] = f[i - 1]` 。
  2. 选择第 `i` 头牛，由题目可知道不能选择连续 `k` 头牛。那么 `w[i - k + 1]~w[i]` 中不能连续。这样的话可以枚举不选择哪一头牛来得到最大值。
     + 假设不选择的牛的编号是 `j` ，那么可以得到 `f[i] = f[j - 1] + s[i] - s[j]` 。其中 `s[i] - s[j]` 是前缀和，记录下的是 `(j + 1)~i` 的和。其可以变换为 `f[i] = (f[j - 1] + s[j]) + s[i]` 。那么这里可以看到只有 `s[i]` 与 `i` 有显性的关系。
     +  其中有 `i - j <= k` 。
     + 那么我们可以维护一个队列，队头元素是 `[i - k, i]` 中 `f[j - 1] + s[j]` 的最大值的下标。在维护这个队列的同时遍历整个前缀和数组，每次 `f[i] = max(f[i - 1], 计算函数(队头元素) + s[i])` ，最后 `f[n]` 即为答案。

+ ```cpp
  #include <bits/stdc++.h>
  
  using namespace std;
  
  #define pb push_back
  
  typedef long long ll;
  
  const int N = 1E5 + 10;
  int n, k;
  ll s[N], f[N];
  
  ll g(int i)
  {
      if (!i) return 0;
      
      return f[i - 1] - s[i];
  }
  
  signed main()
  {
      cin >> n >> k;
      
      for (int i = 1; i <= n; i ++ ) cin >> s[i], s[i] += s[i - 1];
      
      deque<int> q;
      q.push_front(0);
      
      for (int i = 1; i <= n; i ++ ) 
      {
          if (q.front() < i - k) q.pop_front();   
          f[i] = max(f[i - 1], g(q.front()) + s[i]);
          
          while (q.size() && g(q.size()) <= g(i)) q.pop_back();
          q.push_back(i);
      }
      
      cout << f[n] << endl;
      
      return 0;
  }
  ```

# 搜索

### A star

#### 第k短路

+ `A*` 问题的核心思想是： **在BFS中，如果所有边权都是非负的，那么就可以用启发函数来优化BFS过程** 。

+ `dijkstra` 算法可以用数学归纳法和反证法来证明：
  + 如果有一个 `s` 点，当前 `st[s] = true` ，有 `t` 点可以走到 `s` 点。因为 `dist[s] <= dist[t]` ，因此如果再 `dist[t] + s->t` ，也不可能让 `dist[s]` 更小。得证。
  
+ ![image-20210630145141727](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master//image-20210630145141727.png)

+ ```cpp
  #include <iostream>
  #include <string.h>
  #include <stdio.h>
  #include <queue>
  #include <algorithm>
  #include <vector>
  
  using namespace std;
  
  typedef pair<int, int> pii;
  typedef pair<int, pii> piii;
  typedef pii PII;
  typedef piii PIII;
  #define xx first
  #define yy second
  #define x first
  #define y second
  
  const int N = 1010, M = 200010;
  
  int n, m;
  int S, T, K;
  int e[M], ne[M], w[M], h[N], rh[N], idx;
  bool st[N];
  int dist[N];
  int cnt[N];
  
  void add(int *h, int a, int b, int c)
  {
      e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++ ;
  }
  void dijkstra()
  {
      memset(dist, 0x3f, sizeof dist);
      priority_queue<pii, vector<pii>, greater<pii>> heap;
      heap.push({0, T});
      dist[T] = 0; // 倒着dij
  
      while (heap.size())
      {
          int t = heap.top().yy;
          heap.pop();
          if (st[t]) continue;
          st[t] = true;
  
          for (int i = rh[t]; ~i; i = ne[i])
          {
              int j = e[i];
              if (dist[j] > dist[t] + w[i])
              {
                  dist[j] = dist[t] + w[i];
                  heap.push({dist[j], j});
              }
          }
      }
  }
  
  int astar()
  {
      priority_queue<piii, vector<piii>, greater<piii> > heap;
      heap.push({dist[S], {0, S}});
  
      while (heap.size())
      {
          auto t = heap.top();
          heap.pop();
  
          int ver = t.yy.yy, distance = t.yy.xx;
          cnt[ver] ++ ;
          if (cnt[T] == K) return distance;
  
          for (int i = h[ver]; ~i; i = ne[i])
          {
              int j = e[i];
              if (cnt[j] < K) 
                  heap.push({distance + w[i] + dist[j], {distance + w[i], j}});
          }
      }
  
      return -1;
  }
  
  int main()
  {
      cin >> n >> m;
  
      memset(h, -1, sizeof h);
      memset(rh, -1, sizeof rh);
      while (m -- )
      {
          int a, b, c;
          cin >> a >> b >> c;
          add(h, a, b, c), add(rh, b, a, c);
      }
  
      cin >> S >> T >> K;
      if (S == T) K ++ ;
  
      dijkstra();
  
      printf("%d\n", astar());
  
      return 0;
  }
  ```

#### 八数码

+ 八数码问题无解当且仅当 **逆序对数量是奇数** 。如果是偶数则一定有解。

+ `A*` 算法的主要思想就是把当前点到终点的距离更新为 `dist[i] + f(i)` ，其中 `f(i)` 要小于等于真实距离。

  ```cp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <unordered_map>
  #include <algorithm>
  #include <string>
  #include <string.h>
  #include <queue>
  
  using namespace std;
  
  #define xx first
  #define yy second
  
  int f(string state)
  {
      int res = 0;
      for (int i = 0; i < state.size(); i ++ )
      {
          if (state[i] == 'x') continue;
          
          int t = state[i] - '1';
          res += abs(i / 3 - t / 3) + abs(i % 3 - t % 3);
      }
      
      return res;
  }
  
  string bfs(string start)
  {
      int dx[4] = {-1, 0, 1, 0};
      int dy[4] = {0, 1, 0, -1};
      char op[4] = {'u', 'r', 'd', 'l'};
      
      string end = "12345678x";
      unordered_map<string, int> dist;
      unordered_map<string, pair<string, int>> prev;
      priority_queue<pair<int, string>, vector<pair<int, string>>, greater<pair<int, string>>> heap;
      
      heap.push({f(start), start});
      dist[start] = 0;
      
      while (heap.size())
      {
          auto t = heap.top();
          heap.pop();
          
          string state = t.yy;
          if (state == end) break;
          
          int step = dist[state];
          int x, y;
          for (int i = 0; i < state.size(); i ++ )
              if (state[i] == 'x')
              {
                  x = i / 3, y = i %  3;
                  break;
              }
              
          string source = state;
          for (int i = 0; i < 4; i ++ )
          {
              int a = x + dx[i], b = y + dy[i];
              
              swap(state[x * 3 + y], state[a * 3 + b]);
              if (a >= 0 && a < 3 && b >= 0 && b < 3)
              {
                  if (!dist.count(state) || dist[state] > step + 1)
                  {
                      dist[state] = step + 1;
                      prev[state] = {source, op[i]};
                      heap.push({dist[state] + f(state), state});
                  }
              }
              swap(state[x * 3 + y], state[a * 3 + b]);
          }
      }
      
      string res;
      while (end != start)
      {
          res += prev[end].yy;
          end = prev[end].first;
      }
      reverse(res.begin(), res.end());
      
      return res;
  }
  
  int main()
  {
      string g, c, seq;
      while (cin >> c)
      {
          g += c;
          if (c != "x") seq += c;
      }
      
      int t = 0;
      for (int i = 0; i < seq.size(); i ++ )
          for (int j = i + 1; j < seq.size(); j ++ )
              if (seq[i] > seq[j])
                  t ++ ;
      
      if (t % 2) puts("unsolvable");
      else cout << bfs(g) << endl;
      
      return 0;
  }
  ```

#### 矩阵距离

+ ![image-20211127195622680](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127195622680.png)

+ 这道题可以把所有为1的点放到队列里面，然后多元开始宽搜。搜完了之后每一个点是在第几层被搜到的就证明其到最近的1的最短距离。

+ 因为是宽搜，每个点最多只能被搜到一次，因此时间复杂度是 $0(n)$ 的。

+ 写bfs的时候有一个技巧，不用设置st数组，直接给dist数组设置一个特殊的初始值，如果得到的值是这个数字就说明其没有进入过队列。这样可以省下一个数组的空间开销。

  ```cpp
  #include <iostream>
  #include <string.h>
  #include <stdio.h>
  #include <algorithm>
  #include <queue>
  
  using namespace std;
  
  typedef pair<int, int> pii;
  #define xx first
  #define yy second
  
  const int N = 1010;
  
  int n, m;
  char a[N][N];
  int d[N][N];
  
  int dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0};
  
  void bfs()
  {
      memset(d, -1, sizeof d);
      queue<pii> q;
      for (int i = 0; i < n; i ++ )   
          for (int j = 0; j < m; j ++ )
              if (a[i][j] == '1')
              {
                  d[i][j] = 0;
                  q.push({i, j});
              }
  
      while (q.size())
      {
          auto t = q.front();
          q.pop();
          int x = t.xx, y = t.yy;
  
          for (int i = 0; i < 4; i ++ )
          {
              int tx = x + dx[i], ty = y + dy[i];
              if (tx >= 0 && ty >= 0 && tx <= n && ty <= m && d[tx][ty] == -1)
              {
                  q.push({tx, ty});
                  d[tx][ty] = d[x][y] + 1;
              }
          }
      }
  }
  
  int main()
  {
      cin >> n >> m;
      for (int i = 0; i < n; i ++ ) cin >> a[i];
  
      bfs();
  
      for (int i = 0; i < n; i ++ ) 
      {
          for (int j = 0; j < m; j ++ ) 
              printf("%d ", d[i][j]);
          puts("");
      }
  
      return 0;
  }
  ```

#### 电路维修

+ 在更新了边权之后，如果当前路的长度为0，那么dist和原来的一样，那么这个就不能推入到队列的末尾中。因为在 `bfs` 的时候整个队列需要保证 **两端性和单调性** 。如果让dist没有增加的点放到最后，势必会破坏整个队列的单调性。

#### 字串变换

+ ![image-20211127195808864](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127195808864.png)

  ![image-20211127195825969](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127195825969.png)

+ 双向广搜一般用在 **最小步数** 问题中。在最短路、flood fill问题中一般用不到。

+ 在扩展的时候一定有一边的可能状态多，一边的可能状态少。在扩展的时候每次都应该选择状态少的一边进行扩展（在这道题里面是字符串长度较短）。这样可以保证时间空间用得最少。

  ```cpp
  #include <stdio.h>
  
  #include <algorithm>
  #include <iostream>
  #include <queue>
  #include <string>
  #include <unordered_map>
  
  using namespace std;
  
  const int INF = 0x3f3f3f3f;
  
  typedef unordered_map<string, int> usi;
  typedef queue<string> qs;
  
  int n;
  vector<string> va, vb;
  
  int extend(qs &q, usi &da, usi &db, vector<string> &a, vector<string> &b)
  {
      auto t = q.front();
      q.pop();
  
      for (int i = 0; i < (int)(t.size()); i++)
      {
          for (int j = 0; j < n; j++)
          {
              string tt = t.substr(i, a[j].size());
              string ttt = a[j];
              if (t.substr(i, a[j].size()) == a[j])
              {
                  string state =
                      t.substr(0, i) + b[j] + t.substr(i + a[j].size());
                  if (da.count(state))
                      continue;
                  if (db.count(state))
                      return db[state] + da[t] + 1;
  
                  da[state] = da[t] + 1;
                  q.push(state);
              }
          }
      }
  
      return INF;
  }
  
  int bfs(string A, string B)
  {
      usi da, db;
      queue<string> qa, qb;
      qa.push(A), qb.push(B);
      da[A] = 0, db[B] = 0;
  
      while (qa.size() && qb.size())
      {
          int t;
          if (qa.size() <= qb.size())
              t = extend(qa, da, db, va, vb);
          else
              t = extend(qb, db, da, vb, va);
  
          if (t <= 10)
              return t;
      }
  
      return INF;
  }
  
  int main()
  {
      string A, B;
      cin >> A >> B;
  
      string s1, s2;
      while (cin >> s1 >> s2)
      {
          va.push_back(s1), vb.push_back(s2);
          n++;
      }
  
      int res = bfs(A, B);
  
      if (res > 10)
          puts("NO ANSWER!");
      else
          cout << res << endl;
  
      return 0;
  }
  ```


### 马走日

+ 这道题是一个外部搜索

+ 每次搜索结束之后恢复现场。

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 110;
  
  bool st[N][N];
  
  int n, m;
  int ans;
  
  int dx[] = {1, 1, -1, -1, 2, 2, -2, -2};
  int dy[] = {2, -2, 2, -2, 1, -1, 1, -1};
  
  void dfs(int x, int y, int cnt)
  {
      if (cnt == n * m)
      {
          ans ++ ;
          return;
      }
      
      st[x][y] = true;
      
      for (int i = 0; i < 8; i ++ )
      {
          int tx = x + dx[i];
          int ty = y + dy[i];
          
          if (tx < 0 || ty < 0 || tx >= n || ty >= m) continue;
          if (st[tx][ty]) continue;
          
          dfs(tx, ty, cnt + 1);
      }
      
      st[x][y] = false;
  }
  
  int main()
  {
      int T;
      cin >> T;
      
      while (T -- )
      {
          ans = 0;
          
          int x, y;
          cin >> n >> m >> x >> y;
          
          dfs(x, y, 1);
          
          cout << ans << endl;
      }
      
      return 0;
  }
  ```

### 单词接龙

+ ![image-20211127195915152](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127195915152.png)

+ 这也是一个外部搜索，每次搜索到不同的状态之后要将状态进行还原。

+ 首先预处理一遍把所有的字符串两两对应的重合部分算出来，然后进行外部搜索。每次搜索的时候遍历所有字符串，如果发现有可以继续下去并且使用次数少于2的就接上龙继续dfs下去，在dfs结束之后 `used[last] -- ` 恢复现场。

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  #include <string>
  #include <string.h>
  
  using namespace std;
  
  const int N = 110;
  
  string word[N];
  int n;
  int used[N];
  int g[N][N];
  int ans;
  
  void dfs(string dragon, int last)
  {
      ans = max((int)dragon.size(), ans);
      
      used[last] ++ ;
      
      for (int i = 0; i < n; i ++ )
      {
          if (g[last][i] && used[i] < 2)
              dfs(dragon + word[i].substr(g[last][i]), i);
      }
      
      used[last] -- ;
  }
  
  int main()
  {
      cin >> n;
      for (int i = 0; i < n; i ++ ) cin >> word[i];
      
      char start;
      cin >> start;
      
      for (int i = 0; i < n; i ++ )
          for (int j = 0; j < n; j ++ )
          {
              string a = word[i], b = word[j];
              for (int k = 1; k < min(a.size(), b.size()); k ++ )
                  if (a.substr(a.size() - k) == b.substr(0, k))
                  {
                      g[i][j] = k;
                      break;
                  }
          }
          
      for (int i = 0; i < n; i ++ )
          if (word[i][0] == start)
              dfs(word[i], i);
              
              
      cout << ans << endl;
      
      return 0;
  }
  ```

### 分成互质组

+ ![image-20211127195931510](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127195931510.png)

+ 如果当前的组里面能放下新的数，一定不能新开一个组。因为如果新开一个组能得到最优解的话，那么把这个数放回到原来的那个能放这个数的组里面也是最优解（？）

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 10;
  
  int p[N];
  int group[N][N];
  int ans = N;
  bool st[N];
  int n;
  
  int gcd(int a, int b)
  {
      return b ? gcd(b, a % b) : a;
  }
  
  // 判断i下标的数和这个组中的元素是不是全部互质
  bool check(int group[], int gc, int i)
  {
      for (int j = 0; j < gc; j ++ )
          if (gcd(p[group[j]], p[i]) > 1)
              return false;
              
      return true;
  }
  
  // u表示当前遍历到第几个组，gc表示当前组内的下标
  // tc表示当前遍历到第几个元素（一共有几个元素）
  // start表示当前可以从哪个元素开始搜（？tc和start不重复吗）
  void dfs(int u, int gc, int tc, int start)
  {
      // 说明不是最优解
      if (u >= ans) return;
      if (tc == n) ans = u; // 为什么不return？
      
      bool flag = true;
      for (int i = start; i < n; i ++ )
      {
          // 如果这个数没有被用过而且第i个元素与其是互质的
          // 那么可以用这个数
          if (!st[i] && check(group[u], gc, i))
          {
              st[i] = true;
              group[u][gc] = i;
              
              dfs(u, gc + 1, tc + 1, i + 1);
              
              st[i] = false;
              
              flag = false;
          }
      }
      
      // 如果不能添加到任何一个已有的组中
      if (flag) dfs(u + 1, 0, tc, 0);
  }
  
  int main()
  {
      cin >> n;
      
      for (int i = 0; i < n; i ++ ) cin >> p[i];
      
      dfs(1, 0, 0, 0);
      
      cout << ans << endl;
      
      return 0;
  }
  ```

### 小猫爬山

+ ![image-20211127195954745](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127195954745.png)

+ 这道题看起来像是背包，但是w和c都异常地大，不是背包问题。要爆搜，但是要注意剪枝否则tle

+ 这道题一共有两种决策。

  1. 放到一个已有的车中
  2. 新加一个车，放到新加的这个车里面

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 30;
  int n, m;
  int cat[N], sum[N];
  int ans = N;
  
  // 第u只猫，当前花费为k
  void dfs(int u, int k)
  {
      if (k >= ans) return;
      
      if (u == n) 
      {
          ans = k;
          return;
      }
      
      // 1.放到当前已有的一辆车里面
      for (int i = 0; i < k; i ++ )
      {
          if (cat[u] + sum[i] <= m)
          {
              sum[i] += cat[u];
              
              dfs(u + 1, k);
              
              sum[i] -= cat[u];
          }
      }
      
      // 2.新加一辆车
      sum[k] = cat[u];
      dfs(u + 1, k + 1);
      sum[k] = 0;
  }
  
  int main()
  {
      cin >> n >> m;
      for (int i = 0; i < n; i ++ ) cin >> cat[i];
      
      // 优先考虑大的，决策的方案少
      // sort(cat, cat + n, [](int x, int y) -> int {
      //     x > y;
      // });
      sort(cat, cat + n);
      reverse(cat, cat + n);
      
      dfs(0, 0);
      
      cout << ans << endl;
      
      return 0;
  }
  ```

### 木棒

+ ![image-20211127200023692](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127200023692.png)

+ 剪枝
  1. 按从小到大的顺序枚举木棒
  2. 木棒内部编号递增
  3. 跳过所有相等木棒
  4. 如果放第一个木棒失败了，则必定失败
  5. 如果放最后一个木棒失败了，则必定失败

+ ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 70;
  
  int n, length;
  bool st[N];
  int w[N];
  int sum;
  
  // u是当前是第几根棍子，part是当前棍子多长，start是从第几个开始遍历
  bool dfs(int u, int part, int start)
  {
      // 如果总长度到达了
      if (u * length == sum) return true;
      
      if (part == length) return dfs(u + 1, 0, 0);
      
      for (int i = start; i < n; i ++ )
      {
          // 被用过了
          if (st[i]) continue;
          
          if (w[i] + part > length) continue;
          
          st[i] = true;
          if (dfs(u, w[i] + part, i + 1)) return true;
          st[i] = false;
          
          //??如果第一根或者最后一根失败了
          if (!part || w[i] + part == length) return false;
          
          int j = i;
          while (j < n && w[j] == w[i]) j ++ ;
          i = j - 1;
      }
      
      return false;
  }
  
  int main()
  {
      while (cin >> n, n)
      {
          length = 1, sum = 0;
          memset(st, false, sizeof st);
          for (int i = 0; i < n; i ++ )
          {
              scanf("%d", &w[i]);
              sum += w[i];
          }
          
          sort(w, w + n);
          reverse(w, w + n);
          
          while (1)
          {
              if (sum % length == 0 && dfs(0, 0, 0))
              {
                  printf("%d\n", length);
                  break;
              }
              length ++ ;
          }
      }
      
      return 0;
  }
  ```

### 数独

+ ![image-20211127200553879](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127200553879.png)

+ 顺序
  1. 每次随意挑选空的格子
  2. 枚举每个可以挑选的数字
  3. dfs
  
  ```cpp
  #include <stdio.h>
  #include <string.h>
  
  #include <algorithm>
  #include <iostream>
  #include <string>
  
  using namespace std;
  
  const int N = 9, M = 1 << N + 1;
  int mp[M];  // 用来打表表示这个数是1左移几位
  char s[110];
  int rows[N], cols[N], cell[3][3];
  int ones[M];
  
  inline int lowbit(int x)
  {
      return x & -x;
  }
  
  // is_set = true则(x,y)填上t，否则删掉
  void draw(int x, int y, int t, bool is_set)
  {
      if (is_set)
          s[x * N + y] = '1' + t;
      else
          s[x * N + y] = '.';
  
      int v = 1 << t;
      if (!is_set)
          v = -v;
  
      rows[x] -= v;
      cols[y] -= v;
      cell[x / 3][y / 3] -= v;
  }
  
  int init()
  {
      // cnt表示还剩几个数字没填
      int cnt = 0;
  
      // 初始状态state的9位二进制全是1
      int state = (1 << N) - 1;
  
      // 如果row[0] = 111111111 代表第一行可以填9个数。这里行号是0~8
      fill(rows, rows + N, state);
      fill(cols, cols + N, state);
      fill(cell[0], cell[0] + N, state);
  
      for (int i = 0, k = 0; i < N; i++)
          for (int j = 0; j < N; j++, k++)
              if (s[k] != '.')
                  draw(i, j, s[k] - '1', true);
              else
                  cnt++;
  
      return cnt;
  }
  
  inline int get(int x, int y)
  {
      // 为1可填，所有均可填的话是所有都与在一起
      return rows[x] & cols[y] & cell[x / 3][y / 3];
  }
  
  bool dfs(int cnt)
  {
      // 填完所有数字则返回
      if (!cnt)
          return true;
  
      // 选出可以填的数字最少的分支进行搜索。优化
      int minv = 10;
      int x, y;
      for (int i = 0; i < N; i++)
          for (int j = 0; j < N; j++)
          {
              if (s[i * N + j] == '.')
              {
                  // 可以填的数字状态，某一位是1说明可以填
                  int state = get(i, j);
                  // 选一个1的个数最少的，这样的分支数目最少
                  if (ones[state] < minv)
                  {
                      minv = ones[state];
                      x = i, y = j;
                  }
              }
          }
  
      // 依次做lowbit操作，选择每个分支
      for (int i = get(x, y); i; i -= lowbit(i))
      {
          // 这个t就是要填充的数字
          int t = mp[lowbit(i)];
  
          // 填入这个数字
          draw(x, y, t, true);
  
          // 这次填充成功了，找到了，则返回
          if (dfs(cnt - 1))
              return true;
  
          // 失败则回溯
          draw(x, y, t, false);
      }
  
      return false;
  }
  
  int main()
  {
      // 打表，快速地知道是哪一个数字
      for (int i = 0; i < N; i++)
          mp[1 << i] = i;
  
      // ones记录每个状态有多少个1，用于选择分支少的开始搜索
      for (int i = 0; i < M; i++)
          for (int j = i; j; j -= lowbit(j))
              ones[i] += 1;
  
      while (cin >> s, *s != 'e')
      {
          int k = init();
          dfs(k);
          puts(s);
      }
  
      return 0;
  }
  ```

### 加成序列

+ ![image-20211127200618468](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127200618468.png)
+ ![image-20211127200624567](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127200624567.png)

+ 如果已经确定了最终的结果所在的位置是比较浅的位置，那么就应该使用迭代加深。虽然非常浅的位置会被重复搜索很多遍，但是相比起搜索到较深的地方所耗费的时间，重复搜索较浅的位置所花费的时间基本上可以忽略不记。

+ 这里 `while (!dfs(1, k)) k ++ ;` 。通过 `k` 来限制迭代的层数。这样不会一路走到死花费过多的时间在非常深的地方。

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 110;
  
  int path[N];
  int n;
  
  // u是当前的深度，depth是最深的深度
  bool dfs(int u, int max_depth)
  {
      if (u == max_depth) return path[u - 1] == n;
      
      bool st[N];
      memset(st, false, sizeof st);
      
      for (int i = u - 1; i >= 0; i -- )
      {
          for (int j = i; j >= 0; j -- ) 
          {
              int t = path[i] + path[j];
              
              if (t > n || path[u - 1] >= t || st[t]) continue;
              
              st[t] = true;
              path[u] = t;
              if (dfs(u + 1, max_depth)) return true;
          }
      }
      
      return false;
  }
  
  int main()
  {
      path[0] = 1;
      while (cin >> n, n)
      {
          int k = 1;
          
          // 不断加深最深的层数
          while (!dfs(1, k)) k ++ ;
          
          for (int i = 0; i < k; i ++ ) cout << path[i] << " ";
          cout << endl;
      }
      
      return 0;
  }
  ```

### 送礼物（双向dfs）

+ ![image-20211127201217682](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127201217682.png)

+ 除了迭代加深之外，双向dfs也可以很大程度上避免在深层子树上浪费时间。在一些题目中，问题不仅具有“初态”，而且还具有明确的“终态”。并且从初态到终态搜索产生的搜索树能够覆盖整个状态空间。在这种情况下， 就可以使用双向搜索。从初态和终态出发各搜索一半状态，产生两颗深度减半的搜索树，在中间交汇，组合成最终的答案。

+ 做法
  1. 将所有物品按重量从大到小排序
  2. 先将前 $K$ 件物品能凑出的所有重量打表。然后排序并判重。
  3. 搜索剩下的 $N-K$ 件物品的选择方式，然后在表中二分出不超过 $W$ 的最大值。
  
+ 这里首先对于前一半进行打表，打出一个前一半的所有可能结果的表。然后再在后一半中进行元素的选择。这样预处理前一半的时间复杂度是 $O(2^{23})$ ，而在之后再进行二叉查找找到前一半的中最合适的组合的时间复杂度是 $O(log_{2^{23}})$ 。这样合起来的时间复杂度是 $O(2^{23}log_2{23})$ ，可以通过。这里运用了双向dfs和用时间换空间的想法。

+ `int ct = unique(a, a + n) - a` 这里把a（已经排好序了的一个容器）进行去重，并且得出 `ct` 是这个容器中去重之后剩下的元素个数。

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <algorithm>
  
  using namespace std;
  
  typedef long long ll;
  
  const int N = 46;
  
  int n, m, k;
  int w[N];
  int weights[1 << 25], cnt = 1;
  int ans;
  
  // u表示当前枚举到哪个数了，s表示当前的和
  void dfs1(int u, int s)
  {
      // 如果已经搜到了k
      if (u == k)
      {
          // 进行记录
          weights[cnt ++ ] = s;
          return;
      }
      
      dfs1(u + 1, s); // 不选这个元素
      
      // 如果选了这个元素不会超过限制
      if ((ll)s + w[u] <= m)
          dfs1(u + 1, s + w[u]);
  }
  
  void dfs2(int u, int s)
  {
      // 如果选的元素的下标等于n了，说明选完了，这时候从前面
      // 事先预处理的数组weights中选出应该选择的前面的组合
      if (u == n)
      {
          int l = 0, r = cnt - 1;
          while (l < r)
          {
              int mid = l + r + 1 >> 1;
              if ((ll)s + weights[mid] <= m) l = mid;
              else r = mid - 1;
          }
          // 更新答案中存放的最大值
          ans = max(ans, s + weights[l]);
          return;
      }
      
      // 不选这个元素
      dfs2(u + 1, s);
      // 选这个元素
      if ((ll)s + w[u] <= m) dfs2(u + 1, s + w[u]); 
  }
  
  int main()
  {
      cin >> m >> n;
      for (int i = 0; i < n; i ++ ) cin >> w[i];
      
      sort(w, w + n);
      reverse(w, w + n); // 大的放在前面
      
      // 只到k，n / 2 + 2是推出来的最佳选择
      k = n / 2 + 2;
      dfs1(0, 0);
      
      sort(weights, weights + cnt);
      cnt = unique(weights, weights + cnt) - weights;
      
      dfs2(k, 0);
      
      cout << ans << endl;
      
      return 0;
  }
  ```

### 排书

+ ![image-20211127201251839](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127201251839.png)
+ ![image-20211127201314859](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127201314859.png)

+ `A*` 和 `IDA*` 的区别应该是 `A*` 是普通的bfs加上 $f(n)$ 启发函数，而 `IDA*` 是迭代加深的思想，按照 $f(n)$ 启发函数来确定搜索的层数。

+ 在这道题里面，如果当前深度 + 未来估计步数 > 深度限制，就可以进行回溯了。我们可以发现，移动一串数字最多可以改变3个数字的后继。（比如 `1 2 3 4 5 6`  ，移动一次 `1 4 2 3 5 6` ，这里1、4、3的后继改变了，其他的没有变化）因此我们每一次统计当前序列中一共有多少个不合法的后继。因此估价函数如下 $f(n)=\lceil {\frac{不合法的后继数量}{3}} \rceil$ 。

+ `l` 是需要移动的序列的左边界限， `r` 是需要移动的右边界限。 `k` 是需要插入的位置。插入的位置是 `k` 元素的后面的位置。

  ![image-20210711145429107](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master//image-20210711145429107.png)

  由于这里把前面一段放到后面去和把后面一段放到前面来在结果上是一样的。所以 `k` 直接从 `r + 1` 开始枚举就可以了。不需要从前面开始枚举，因为这样会浪费时间搜索相同的结果。
  
  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 15;
  
  int n;
  int q[N];
  int w[5][N];
  
  int f()
  {
      int cnt = 0;
      for (int i = 0; i < n - 1; i ++ ) 
          if (q[i + 1] != q[i] + 1)
              cnt ++ ;
              
      return (cnt + 2) / 3;
  }
  
  bool check()
  {
      for (int i = 0; i < n - 1; i ++ )
          if (q[i + 1] != q[i] + 1)
              return false;
              
      return true;
  }
  
  bool dfs(int depth, int max_depth)
  {
      // 用f来剪枝
      if (depth + f() > max_depth) return false;
      if (check()) return true;
      
      // 移动的序列的长度
      for (int len = 1; len <= n; len ++ ) 
          for (int l = 0; l + len - 1 < n; l ++ ) // 移动序列左边的起始位置
          {
              int r = l + len - 1;
              
              // 插入的位置，把[l,r]的东西放到k元素的后面去
              for (int k = r + 1; k < n; k ++ )
              {
                  // 保存现场
                  memcpy(w[depth], q, sizeof q);
                  
                  int x, y;
                  for (x = r + 1, y = l; x <= k; x ++ , y ++ )
                      q[y] = w[depth][x];
                  for (x = l; x <= r; x ++ , y ++ )
                      q[y] = w[depth][x];
              
                  // 移动完了进行搜索
                  if (dfs(depth + 1, max_depth)) return true;
                  // 回溯
                  memcpy(q, w[depth], sizeof q);
              }
          }
          
      return false;
  }
  
  int main()
  {
      int T;
      cin >> T;
      
      while (T -- )
      {
          cin >> n;
          for (int i = 0; i < n; i ++ ) cin >> q[i];
          
          int depth = 0;
          while (depth < 5 && !dfs(0, depth)) depth ++ ;
          if (depth >= 5) puts("5 or more");
          else cout << depth << endl;
      }
      
      return 0;
  }
  ```

### 回转游戏

+ ![image-20211127201713445](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127201713445.png)
+ ![image-20211127201728186](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127201728186.png)

+ 这里的启发函数 $f(n)=8-cnt$ 。其中 $cnt$ 是中间一圈中相同的元素的个数。

+ `IDA*` 看起来还是跟 `A*` 不太一样。 `IDA*` 是用来剪枝，而 `A*` 虽然也是一种剪枝，但是看上去很像是使用启发算法 $f(n)$ 来得到了一个近似的距离。而 `IDA*` 不是这样。

+ 这里因为如果使用了这一条线的一个操作，那么如果重复往这一条线的另一个操作方向去查找的话就会重复查找。因此这里需要存放一个 `opposite` 来确定某一个操作的反向操作是什么。如果进行了这个操作就不继续查找这个操作的反向操作

  ```cpp
  /*
        0     1
        2     3
  4  5  6  7  8  9  10
        11    12
  13 14 15 16 17 18 19
        20    21
        22    23
  */
  
  
  #include <cstdio>
  #include <cstring>
  #include <iostream>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 24;
  
  int q[N];
  int op[8][7] = {
      {0, 2, 6, 11, 15, 20, 22},
      {1, 3, 8, 12, 17, 21, 23},
      {10, 9, 8, 7, 6, 5, 4},
      {19, 18, 17, 16, 15, 14, 13},
      {23, 21, 17, 12, 8, 3, 1},
      {22, 20, 15, 11, 6, 2, 0},
      {13, 14, 15, 16, 17, 18, 19},
      {4, 5, 6, 7, 8, 9, 10}
  };
  int center[8] = {6, 7, 8, 11, 12, 15, 16, 17};
  // 用来存放每一个操作的反向操作
  int opposite[8] = {5, 4, 7, 6, 1, 0, 3, 2};
  
  int path[100];
  
  bool check()
  {
      for (int i = 1; i < 8; i ++ )
          if (q[center[i]] != q[center[0]]) 
              return false;
              
      return true;
  }
  
  void operation(int x)
  {
      int t = q[op[x][0]];
      for (int i = 0; i < 6; i ++ ) q[op[x][i]] = q[op[x][i + 1]];
      q[op[x][6]] = t;
  }
  
  // 算出中间最多的数字有几个
  int f()
  {
      static int sum[4];
      memset(sum, 0, sizeof sum);
      
      for (int i = 0; i < 8; i ++ ) sum[q[center[i]]] ++ ;
      
      int s = 0;
      for (int i = 1; i <= 3; i ++ ) s = max(s, sum[i]);
      
      return 8 - s;
  }
  
  // depth用来表示当前的深度，max_depth用来表示最深深度
  // last用来表示上一次进行的操作，以免进行相反的操作
  bool dfs(int depth, int max_depth, int last)
  {
      // 使用启发函数剪枝
      if (depth + f() > max_depth) return false;
      // 判断成功
      if (check()) return true;
      
      for (int i = 0; i < 8; i ++ )
      {
          // 如果和上一次操作是相反操作，直接跳过
          if (opposite[i] == last) continue;
          
          // 变换
          operation(i);
          
          path[depth] = i;
          if (dfs(depth + 1, max_depth, i)) return true;
          
          // 恢复现场
          operation(opposite[i]);
      }
      
      return false;
  }
  
  int main()
  {
      while (scanf("%d", &q[0]), q[0])
      {
          for (int i = 1; i < N; i ++ ) cin >> q[i];
          
          int max_depth = 0;
          while (!dfs(0, max_depth, -1)) max_depth ++ ;
          
          // 如果depth是0的时候就返回了，说明初始状态就是正确的
          if (!max_depth) printf("No moves needed");
          else
              for (int i = 0; i < max_depth; i ++ ) 
                  printf("%c", 'A' + path[i]); 
      
          printf("\n%d\n", q[6]);
      }
      
      return 0;
  }
  ```

###  dfs优化

+ 优化搜索顺序，优先搜索分支少的
+ 排除冗余信息
+ 可行性检查

# 图论

+ 所有的最小生成树，prim或kruskal，都是无向边。

### 局域网

+ ![image-20211127202153740](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127202153740.png)
+ ![image-20211127202204100](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127202204100.png)

+ 相当于在每一个块中求一颗生成树。相当于求一个”生成森林“。

+ 这道题说要求删去的边权和最大的，也就是说求剩下的边权和最小的。因此可以求出每个联通块的最小生成树，求出的这个最小生成树组成的森林就是最后生下来的图。

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 1010, M = N * 2;
  
  int p[M];
  int n, m;
  
  struct Node
  {
      int a, b, w;
      bool operator< (const Node& t) const
      {
          return w < t.w; 
      }
  } e[M];
  
  int find(int a)
  {
      if (a != p[a]) p[a] = find(p[a]);
      return p[a];
  }
  
  int main()
  {
      for (int i = 0; i < N; i ++ ) p[i] = i;
      cin >> n >> m;
      for (int i = 0; i < m; i ++ )
      {
          int a, b, w;
          cin >> a >> b >> w;
          e[i] = {a, b, w};
      }
      
      sort(e, e + m);
  
      int res = 0;
      
      for (int i = 0; i < m; i ++ )
      {
          int a = e[i].a, b = e[i].b, w = e[i].w;
          a = find(a), b = find(b);
          if (a != b) p[a] = b;
          else res += w;
      }
      
      cout << res << endl;
      
      return 0;
  }
  ```

### 道路与航线

+ ![image-20211127203217264](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127203217264.png)

+ 这题如果直接用spfa来做的话，因为spfa已经死了，所以会被卡成 $O(nm)$ TLE。而因为有负权边的原因，不能直接用 `dij` 来做。这里我们可以发现题目利用恐怖分子之名为我们提供了一个很有用的条件：单向边没有回路。如果通过一条单向边从 `a` 走到 `b` ，那么比不可能通过另外一条单向边从 `b` 走到 `a` 。因此这里我们可以把单向边连起来的每一块看成是一个联通块。因为联通块内部是没有负权边的，因此在联通块内部可以使用 `dij` 来求得最短路。而在联通块之间虽然有负权边，但这些负权边组成了一个 $DAG$ （有向无环图）。因此我们可以通过求拓扑序列的方式来求得其最短路。时间复杂度是 $O(n)$ 。这样我们就能把总体的时间复杂度控制在 $O(nlogm)$ 了。

+ 这道题使用 `spfa` 会被卡掉。

+ 补充知识
  + 如果边权非负，可以用 `dij` ，时间复杂度 $O(mlogn)$ 。
  + 如果是拓扑图（DAG） ，那么不管边权是正是负，均可按拓扑序扫描，时间复杂度是线性 $O(n)$ 的。
  
+ 因为这个图是一个有向无环图，因此可以按照拓扑序列来做，这样的话时间复杂度是OK的。这里直接用 `DFS` 来做。 `BFS` 应该也可以。

+ ![image-20210711184251456](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master//image-20210711184251456.png)

+ 因为这里如果是一条单向边连接了 `a` 和 `b` 的话，那么一定不可以从 `b` 回到 `a` ，所以可以知道 `a` 和 `b` 一定在不同的联通块中。所以每发现一条单向边说明其指向的位置的那个联通块的入度加一。

+ 解决这道题的步骤如下
  1. 首先通过 `flood fill` 类型的 `dfs` 来根据双向边标记出各个联通块。
  2. 在读入单向边预处理一遍，把每个点的入度 `din` 标记一下，为之后的拓扑排序做准备。
  3. 进行拓扑排序。首先把所有的入度为0的点推入队列，然后开始 `while (q.size())` 进行不断地读取。每次读取一个数之后通过 `dijkstra` 来将这个联通块中的所有距离进行更新，在 `dij` 的过程中如果遍历到了入度不为0的点说明这是拓扑排序的队列中应该添加的元素，通过 `q.push` 将其入队。因此这里应该把队列 `q` 设置为全局变量。
  
  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <algorithm>
  #include <math.h>
  #include <vector>
  #include <queue>
  #include <string.h>
  
  using namespace std;
  
  typedef pair<int, int> pii;
  #define xx first
  #define yy second
  
  const int N = 25010 * 2, M = 150010 * 2, INF = 0x3f3f3f3f;
  
  int n, mr, mp, S;
  int w[M], e[M], ne[M], h[N], idx;
  int id[N], din[N], dist[N];
  int bcnt;
  vector<int> block[N];
  queue<int> q;
  bool st[N];
  
  void add(int a, int b, int c)
  {
      e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++ ;
  }
  
  void dijkstra(int bid)
  {
      priority_queue<pii, vector<pii>, greater<pii> > heap;
      
      for (auto i : block[bid])
          heap.push({dist[i], i});
          
      while (heap.size())
      {
          auto t = heap.top();
          heap.pop();
          
          int ver = t.yy, distance = t.xx;
          if (st[ver]) continue;
          st[ver] = true;
          
          for (int i = h[ver]; ~i; i = ne[i])
          {
              int j = e[i];
              // 如果发现这个是另外一个联通块中的元素，并且入度为1，加入队列中
              if (id[j] != id[ver] && -- din[id[j]] == 0) q.push(id[j]); // 先减，再判断是否为0
              
              if (dist[j] > dist[ver] + w[i])
              {
                  dist[j] = dist[ver] + w[i];
                  if (id[j] == id[ver]) heap.push({dist[j], j});
              }
          }
      }
  }
  
  void topsort()
  {
      memset(dist, 0x3f, sizeof dist);
      dist[S] = 0;
      
      // 如果这个联通块的入度为0，入队
      for (int i = 1; i <= bcnt; i ++ )
          if (!din[i])
              q.push(i);
              
      while (q.size())
      {
          auto t = q.front();
          q.pop();
          dijkstra(t);
      }
  }
  
  void dfs(int u, int bid)
  {
      id[u] = bid, block[bid].push_back(u);
      
      for (int i = h[u]; ~i; i = ne[i])
      {
          int j = e[i];
          if (!id[j])
              dfs(j, bid);
      }
  }
  
  int main()
  {
      memset(h, -1, sizeof h);
      memset(dist, 0x3f, sizeof dist);
      cin >> n >> mr >> mp >> S;
      
      for (int i = 0; i < mr; i ++ ) 
      {
          int a, b, c;
          cin >> a >> b >> c;
          add(a, b, c), add(b, a, c);
      }
      
      for (int i = 1; i <= n; i ++ )
          if (!id[i])
              dfs(i, ++ bcnt);
              
      for (int i = 0; i < mp; i ++ )
      {
          int a, b, c;
          cin >> a >> b >> c;
          add(a, b, c);
          din[id[b]] ++ ; // b所属的联通块的入度加1
      }
      
      topsort();
      
      for (int i = 1; i <= n; i ++ )
      {
          if (dist[i] > INF / 2) cout << "NO PATH" << endl;
          else cout << dist[i] << endl;
      }
      
      return 0;
  }
  ```

### 最优贸易

+ 对于 `dijkstra` ，其本质上是一个堆，然后从堆顶取出当前距离最小的点。这个点的距离是不会被其他点更新的。所以如果这个最小值可能被其他点更新的话就不使用 `dijkstra` 算法。

### 选择最佳线路

+ ![image-20211127203521636](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127203521636.png)
+ ![image-20211127203532133](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127203532133.png)

+ 这道题是有多个起点一个终点，要我们求从任意一个起点到终点的最短路径。

+ 这道题和 **昂贵的聘礼** 那道题类似，也是一道使用虚拟原点做的题。我们可以从一个 **虚拟原点** 出发向每个起点连一个长度为0的边。

+ 原问题是求 **任选一个起点到某一个终点的最短距离** ，换句话说，原问题就是所有从每一个起点出发到终点的最短距离。这里如果加上虚拟原点的话，从虚拟原点出发到达终点的所有距离的距离的最小值也就是从任意一个起点到终点的最短距离。

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  #include <queue>
  
  using namespace std;
  
  const int N = 1010, M = 200010, INF = 0x3f3f3f3f;
  int n, m, T;
  int h[N], e[M], w[M], ne[M], idx;
  int dist[N];
  bool st[N];
  
  void add(int a, int b, int c)
  {
      ne[idx] = h[a], e[idx] = b, w[idx] = c, h[a] = idx++;
  }
  
  void spfa()
  {
      memset(dist, 0x3f, sizeof dist);
      memset(st, false, sizeof st);
  
      dist[0] = 0;
      queue<int> q;
  
      q.push(0);
      st[0] = true;
  
      while (q.size())
      {
          auto t = q.front();
          q.pop();
          st[t] = false;
  
          for (int i = h[t]; ~i; i = ne[i])
          {
              int j = e[i];
              if (dist[j] > dist[t] + w[i])
              {
                  dist[j] = dist[t] + w[i];
                  if (!st[j])
                  {
                      q.push(j);
                      st[j] = true;
                  }
              }
          }
      }
  }
  
  int main()
  {
      while (~scanf("%d%d%d", &n, &m, &T))
      {
          memset(h, -1, sizeof h);
          idx = 0;
  
          for (int i = 0; i < m; i++)
          {
              int a, b, c;
              cin >> a >> b >> c;
              add(a, b, c);
          }
  
          int x;
          cin >> x;
          for (int i = 0; i < x; i++)
          {
              int t;
              cin >> t;
              add(0, t, 0); // 虚拟原点到0
          }
  
          spfa();
  
          if (dist[T] > INF / 2) cout << -1 << endl;
          else cout << dist[T] << endl;
      }
  
      return 0;
  }
  ```

### 最短路计数

+ ![image-20211127203700060](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127203700060.png)
+ ![image-20211127203715111](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127203715111.png)

+ 这道题可以用bfs，可以用dij。主要是在每次走到一个点的时候按照拓扑序更新这个点的最短路的条数。

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <algorithm>
  #include <queue>
  #include <string.h>
  
  using namespace std;
  
  const int N = 1E5 + 10, M = N * 4, MOD = 100003, INF = 0x3f3f3f3f;
  int n, m;
  int h[N], e[M], ne[M], idx;
  int cnt[N];
  bool st[N];
  int dist[N];
  
  void add(int a, int b)
  {
      e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
  }
  
  void bfs()
  {
      memset(dist, 0x3f, sizeof dist);
      queue<int> q;
      
      q.push(1);
      dist[1] = 0;
      cnt[1] = 1;
      
      while (q.size())
      {
          auto t = q.front();
          q.pop();
          
          for (int i = h[t]; ~i; i = ne[i])
          {
              int j = e[i];
              // 如果需要更新
              if (dist[j] > dist[t] + 1)
              {
                  dist[j] = dist[t] + 1;
                  cnt[j] = cnt[t];
                  q.push(j);
              }
              // 如果发现了新路径
              else if (dist[j] == dist[t] + 1)
              {
                  cnt[j] += cnt[t] % MOD;
                  cnt[j] %= MOD;
              }
          }
      }
  }
  
  int main()
  {
      memset(h, -1, sizeof h);
      cin >> n >> m;
      for (int i = 0; i < m; i ++ )
      {
          int a, b;
          cin >> a >> b;
          add(a, b), add(b, a);
      }
      
      bfs();
      
      for (int i = 1; i <= n; i ++ ) cout << cnt[i] << endl;
      
      return 0;
  }
  ```

### 牛的旅行

+ 这道题这个题解讲得很详细了 https://www.acwing.com/solution/content/8428/
+ ![image-20210716203332707](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master//image-20210716203332707.png)
+ 首先是通过 `floyd` 求出任意两个点之间的最短路径，然后得出每个点离任意一个点的最长路径，然后遍历一遍首先得出最长路径的最大值 `res1` ，然后再遍历一遍两个块中的点，求出 `res2 = min(maxd[i] + get(i,j) + maxd[j])` ，最后输出 `max(res1, res2)` 。

### 排序

+ ![image-20211127203811795](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127203811795.png)
+ ![image-20211127203826325](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127203826325.png)

+ 这道题其实就是求传递闭包。
+ 在这道题里面在求出传递闭包之后要进行判断
  1. 首先如果发现有 $d(i,i)=1$ ，也就是 `i<i` 的话，说明这个序列一定是不合法的。
  2. 如果发现 $d(i,j)=1$ 而且 $d(i,j)=0$ 的话，可以说明这个序列一定是合法的。
  3. 如果在处理完所有序列之后还是不能完全确定某一个 $d(i,j)$ 的值，说明这个序列是不确定的。
+ 在求最小值的时候用了有点类似拓扑排序的方法。

```cpp
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <math.h>

using namespace std;

const int N = 26;
int n, m;
bool g[N][N], d[N][N];
bool st[N];

void floyd()
{
    memcpy(d, g, sizeof g);
    for (int k = 0; k < n; k ++ )
        for (int i = 0; i < n; i ++ )
            for (int j = 0; j < n; j ++ )
                d[i][j] |= d[i][k] && d[k][j];
}

int check()
{
    // 首先判断i<i是否会发生。如果会发生的话说明不合法。
    for (int i = 0; i < n; i ++ )
        if (d[i][i])
            return 2;
            
    // 如果g(i,j)和g(j,i)均为0，说明还没得到正确的结果
    for (int i = 0; i < n; i ++ )
        for (int j = i + 1; j < n; j ++ )
            if (!d[i][j] && !d[j][i])
                return 0;
                
    return 1;
}

int get_min()
{
    // 如果当前这个点没有任何数字可以大于它，说明这个点是当前最小的点
    for (int i = 0; i < n; i ++ )
        if (!st[i])
        {
            bool flag = true;
            for (int j = 0; j < n; j ++ )
                if (!st[j] && d[j][i]) // 如果j没有被用过而且j大于i
                {
                    flag = false;
                    break;
                }
            
            // 找到了当前最小的数字
            if (flag) 
            {
                st[i] = true;
                return 'A' + i;
            }
        }

    // 不可能执行
    return -1;
}

int main()
{
    while (cin >> n >> m, n || m)
    {
        memset(g, false, sizeof g);
        memset(d, false, sizeof d);
        memset(st, false, sizeof st);
        
        int type = 0, t = -1;
        for (int i = 1; i <= m; i ++ )
        {
            char str[5];
            cin >> str;
            
            int a = str[0] - 'A', b = str[2] - 'A';
            if (!type)
            {
                g[a][b] = true;
                floyd();
                type = check();
                
                if (type) t = i;
            }
        }
        
        if (!type) puts("Sorted sequence cannot be determined.");
        else if (type == 2) printf("Inconsistency found after %d relations.\n", t);
        else
        {
            memset(st, false, sizeof st);
            printf("Sorted sequence determined after %d relations: ", t);
            for (int i = 0; i < n; i ++ ) printf("%c", get_min());
            puts(".");
        }
    }
    
    return 0;
}
```

## 最小生成树

### 联络员

+ ![image-20211127204858041](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127204858041.png)
+ ![image-20211127204909074](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127204909074.png)

+ 这道题某种意义上是一个裸的最小生成树。但是并不太一样，因为这道题有必须要选的边。这里可以用缩点的方法来做。在初始化的时候要把每条必须选的边放入并查集中。

+ 直接在读入的时候判断类型，如果是必须要选的就直接加入到并查集中。如果不是的话就放到边里面。然后按照kruskal来做就可以。

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <algorithm>
  #include <string.h>
  
  using namespace std;
  
  const int N = 20010;
  
  int p[N];
  
  struct Node
  {
      int a;
      int b;
      int w;
  } nodes[N];
  
  int n, m;
  int res;
  int cnt;
  
  bool cmp(Node x, Node y)
  {
      return x.w < y.w;
  }
  
  int find(int x)
  {
      if (x != p[x]) p[x] = find(p[x]);
      return p[x];
  }
  
  int main()
  {
      cin >> n >> m;
      for (int i = 0; i <= n; i ++ ) p[i] = i;
      
      for (int i = 0; i < m; i ++ )
      {
          int t, a, b, w;
          cin >> t >> a >> b >> w;
          if (t == 1) 
          {
              p[find(a)] = find(b);
              res += w;
          }
          else nodes[cnt ++ ] = {a, b, w};
      }
      
      sort(nodes, nodes + cnt, cmp);
      
      for (int i = 0; i < cnt; i ++ )
      {
          int a = nodes[i].a, b = nodes[i].b, w = nodes[i].w;
          int pa = find(a), pb = find(b);
          
          if (pa != pb)
          {
              res += w;
              p[pa] = pb;
          }
      }
      
      cout << res << endl;
      
      return 0;
  }
  ```

### 北极通讯网络

+ ![image-20211127204948417](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127204948417.png)
+ ![image-20211127204959933](https://raw.githubusercontent.com/smallzhong/new_new_picgo_picbed/main/image-20211127204959933.png)

+ 这道题和我做的第一道提高课的题目（监狱那题）有点像。

+ 这道题题意其实就是求在有k个联通块的情况下，每个联通块中最大的距离是多少。

+ 另一个题解中描述题意描述得更形象

  >我们需要找到一个最小的d值,使得在删去权值大于d的所有边后,
  >剩下的联通块个数不超过k.

+ 这里我们不需要二分来做。我们可以直接通过 `kruskal` 来做。因为克鲁斯卡尔的话会从最短的边开始到最长的边。（其实这是类似克鲁斯卡尔，并不是克鲁斯卡尔吧。。只是用了排序和并查集跟克鲁斯卡尔有点像。）这里当我们联通块数小于卫星数 $k$ 的时候，说明已经找到了结果。而答案就是最后一条边的长度，因为最后一条边是最大的。

+ 这道题要注意数据范围，要开 $510*510$ ，因为两重循环，空间 $O(n^2)$ 。

```cpp
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <map>
#include <math.h>

using namespace std;
typedef pair<int, int> pii;
#define xx first
#define yy second

const int N = 1E4 * 510;
int p[N], d[N];
int n, k;
pii q[N];

struct Node
{
    int a;
    int b;
    double w;
} nodes[N];

int cnt;

double get_dist(pii i, pii j)
{
    int x = i.xx - j.xx;
    int y = i.yy - j.yy;
    
    return sqrt(x * x + y * y);
}

int find(int x)
{
    if (x != p[x]) p[x] = find(p[x]);
    return p[x];
}

bool cmp(Node a, Node b)
{
    return a.w < b.w;
}

int main()
{
    cin >> n >> k;
    
    for (int i = 0; i < n; i ++ ) cin >> q[i].xx >> q[i].yy;
    
    // 初始化nodes
    for (int i = 0; i < n; i ++ )
        for (int j = i + 1; j < n; j ++ )
            nodes[cnt ++ ] = {i, j, get_dist(q[i], q[j])};
            
    // kruskal
    sort(nodes, nodes + cnt, cmp);
    for (int i = 0; i <= n; i ++ ) p[i] = i;
    
    // n块
    int kuai = n;
    double res = -1;
    for (int i = 0; i < cnt; i ++ )
    {
        if (kuai <= k) break;
        
        int a = nodes[i].a, b = nodes[i].b;
        double w = nodes[i].w;
        
        int pa = find(a), pb = find(b);
        if (pa != pb)
        {
            kuai -- ;
            res = w;
            p[pa] = pb;
        }
    }

    printf("%.2lf", res);
    
    return 0;
}
```

## 负环

+ 在判负环的时候如果发现TLE了，可以试着把队列换成栈。因为走的序列是按顺序入栈并且先进先出的，所以如果使用栈代替队列的话很可能可以更快速地找到环。

### 观光奶牛

+ 这道题是一道 **01规划** 的题目。要二分求解答案然后判负环确定二分的正确性。
+ 这题判断 `dist` 的地方有点想不明白，先防范，下次做。

## 差分约束

+ 差分约束比较偏数学，在做的时候经常需要在纸上列出很多不等式。
+ 不等式中有很多类似 $x_i\leq x_j+c_k$ 这样的不等式。
+ 差分约束也就是求这样的不等式组的可行解。源点需要满足的条件是：从源点出发，一定可以走到所有的边。
+ 源点需要满足的条件： **从源点出发，一定可以走到所有的边** 。
+ 步骤
  1. 先将每个不等式 $x_i \leq x_j + c_k$ 转换为一条从 $x_i$ 走向 $x_j$ 的边，长度为 $c_k$ 。
  2. 找一个超级源点，使得该源点一定可以遍历到所有边。
  3. 从源点求单源最短路
     1. 结果1：如存在负环，则 原不等式组一定无解。
     2. 结果2：如果没有负环，则 `dist[i]` 就是原不等式组的一个可行解
+ 结论
  + 如果求的是最小值，则应该求最长路。如果求的是最大值，则应该求最短路。

### 糖果

+ 

## 最近公共祖先

+ 解决最近公共祖先问题有两种方法。

  1. 向上标记法 $O(n \cdot m)$

     首先从一个点往上回溯并标记，标记完成后另一个点往上回溯。如果回溯到了之前被标记过的点的话说明这个点是他们的公共祖先。

  2. 倍增法 $O(nlongn)$

     +  `fa[i,j]` 表示从 `i` 开始，向上走 `2 ^ j` 步所能走到的节点。 $0\le j \le \lfloor log_2n \rfloor$ ， `depth[i]` 表示深度 。比如如下的树

     ![image-20210722204934701](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master//image-20210722204934701.png)

     + 对于 `6` 这个结点而言， $f(6,0)=4$ ， $f(6,1)=2$ ， $f(6,2)=  \varnothing$ 。我们在使用倍增法解决这类问题的时候需要先预处理出这样的一个 `f` 数组。
     + 哨兵：如果从 `i` 开始跳 `2 ^ j` 步会跳过根节点，那么 `fa[i,j] = 0` 。规定 `depth[0] = 0` 。
     + 步骤：
       1. 先将 `x` 和 `y` 跳到同一层
       2. 让两个点同时往上跳，一直跳到他们的最近公共祖先的下一层。之所以跳到下一层而不是直接跳到最近公共祖先，因为这样会更加方便我们计算。因为如果 $f(a,k)=f(b,k)$ 的话其实并不能判断出当前是不是最近公共祖先。因为如果不是最近公共祖先的话n也可能是 $f(a,k)=f(b,k)$ 。如果 $f(a,k) \neq f(b,k)$ 的话说明他们还没有跳到最近公共祖先处，需要再往前跳一步。
     + 预处理 $O(nlongn)$ ，查询 $0(logn)$ 。
     + 当 `j = 0` 的时候 $f(i,j)=i的父节点$
     + 当 `j > 0` 的时候 $f(i,j)=f(f(i,j-1),j-1)$ 。

     

### 祖孙询问

+ 

### 距离

+ https://www.acwing.com/solution/content/9034/

+ https://www.acwing.com/solution/content/24569/

+ 这道题可以通过离线的做法来做。首先把所有的查询操作记录下来。然后进行离线操作

+ 第一步是通过dfs来确定每一个点离根节点的距离

+ 然后进行遍历，将已经遍历结束的点标记为 `st[i] = 2` ，正在遍历的点标记为 `st[i] = 1` 。遍历结束这个点之后将其合并到根节点的并查集中。即 `p[当前点]=最深的一个当前st为2的点的父亲` 。这样每次遍历的时候如果发现询问的另一个元素 `st[i] = 2` ，那么就可以知道这两个点的 `lca` 是 `p[另外的那个st=2的点]` 。这样可以通过 `res[id] = dist[u] + dist[y] - dist[t] * 2;` 求出结果。

+ 不是很明白的是为什么选择任意一个点作为根节点，结果都是正确的。

  ![image-20210816210250817](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed/image-20210816210250817.png)

## 有向图的强连通分量

+ ![image-20210723175058065](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master//image-20210723175058065.png)

+ `tarjan` 求 `scc` 。
  + 引入一个 **时间戳** 的概念。 **时间戳** 的定义是这个点是第几步 `dfs` 被搜到的。也就是 `dfs` 序。这样给每一个点加上一个时间戳之后可以发现，一条 **树枝边** 的 `x` 一定是小于 `y` 的。一条 **前向边** 的 `x` 也一定是小于 `y` 的。而一条 **后向边** 的 `x` 是大于 `y` 的，一条 **横叉边** 的 `x` 也是大于 `y` 的。因为横叉边只能是从右往左插。
  + 对每一个点定义两个时间戳：
    1. `dfn[u]` 表示u的dfs序，也就是遍历到 `u` 的时间戳。
    2. `low[u]` 表示从 `u` 开始走，所能遍历到的最小时间戳是什么。
    3. `u` 是其所在的强连通分量的最高点，等价于 `dfn[u] == low[u]` 。
  
+ `tarjan` 板子

  ```cpp
  void tarjan(int u)
  {
      // 首先进行初始化，标记low、dfn，并入栈
      low[u] = dfn[u] = ++ timestamp;
      stk[ ++ top] = u, in_stk[u] = true;
      
      // 遍历所有的边
      for (int i = h[u]; ~i; i = ne[i])
      {
          int j = e[i];
          // 如果发现这个点没有被遍历过，dfs进去
          if (!dfn[j])
          {
              tarjan(j);
              // 回溯之后因为后面的可能有前向边让low[j]更小
              // 因此要更新一下当前点的low。
              low[u] = min(low[u], low[j]);
          }
          // 如果这条边指向的点已经在栈里了，说明这个是前向边。
          // 直接用其指向的那个点的dfs序更新自己。
          else if (in_stk[j]) low[u] = min(low[u], dfn[j]);
      }
      
      // 如果相等，说明当前这个点是这个缩完之后的点中的dfs序最小的点。
      // 这里我们把栈中的全部u之前的元素（包括u）弹出，并进行scc的标记。
      if (dfn[u] == low[u])
      {
          int y = -1;
          ++ scc_cnt;
          do
          {
              y = stk[top -- ];
              in_stk[y] = false;
              id[y] = scc_cnt;
              Size[scc_cnt] ++ ; // 当前scc的大小。
          } while (y != u);
      }
  }
  ```

  这个板子基本上不会变。

### 受欢迎的牛

+ 这篇文章讲得很通俗易懂 https://www.acwing.com/solution/content/20678/

+ 这篇也很好 https://lishizheng.blog.csdn.net/article/details/115121867

+ 这道题其实如果没有环，是一个 `DAG` 的话就会很好做。直接得出出度为0的点就可以。但是这道题是有环的。我们就要用到 `tarjan` 缩点的方法把一个环缩成一个点。 `tarjan` 缩点的时间复杂度是 $0(n+m)$ 。

  ![image-20210724005103807](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master//image-20210724005103807.png)

+ 缩完点之后就很简单了。首先统计缩完后每个点的出度。如果发现有两个及两个以上的点的出度为0，说明无解。否则答案是出度为0的那个点（缩完之后的点，点中不一定只有一个元素）中间元素的个数。

### 学校网络

+ 这道题的第一问和上一题的解法相同。
+ 第二问

>最少需要添加几条新的支援关系，使得将一个新软件提供给任何一个学校，其他所有学校就都可以通过网络获得该软件？

+ 这一句话翻译过来就是至少要加上多少条边可以让整个图变成一个强连通分量。这里的话首先给出结论：求出这个图中的起点个数 `P` 和终点个数 `Q` 。要想把整个图变成一个强连通分量的话需要添加的边数为 `max(P, Q)` 。

### 最大半连通子图

+ 强连通的一定是半联通的。

+ 首先我们将整个图进行缩点。因为强连通分量中满足半联通性，因此在缩点后再求半联通图并不会出现错误。在缩点之后我们可以看到，一条链上的每个点加起来就可以构成一个半联通分量。但是要注意这条链不能够分叉。如果分叉的话岔路两边的两个点必然不满足u可到达v或者v可到达u。

  ![image-20210724150840388](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master//image-20210724150840388.png)

+ 这道题可以通过跑一遍最长路来解决。

## 无向图的双连通分量

+ 对于有向图来说，只有强连通分量scc。但是对于无向图来说，它有两种联通分量。①边双连通分量，②点双连通分量。
+ ![image-20210724215351973](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master//image-20210724215351973.png)

## 二分图

1. 二分图的定义是不存在奇数环，染色法不存在矛盾。
2. 匈牙利算法，匹配、最大匹配、匹配点、增广路径
3. 最小点覆盖、最大独立集、最小路径点覆盖、最小路径重复点覆盖
   + 最大匹配数=最小点覆盖
4. 最优匹配、KM
5. 多重匹配（多夫多妻）

+ 染色法判二分图的时间复杂度是 $O((N + M)logC)$ 。

### 关押罪犯

+ 二分图是针对无向图的

### 棋盘覆盖

+ 最大匹配等价于不存在增广路径。
+ https://www.acwing.com/solution/content/7540/ 这篇题解写的很好

### 机器任务

+ 最大匹配数 = 最小点覆盖 = 总点数 - 最大独立集 = 总点数 - 最小路径覆盖

+ 最小点覆盖就是找到最少的点让所有的边中至少有一个点被选中

  ![image-20210725115212327](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master//image-20210725115212327.png)

+ 这道题可以看作一个二分图，而这个二分图中的每条边都至少要有一个点被选中。这就可以看成一个最小点覆盖的问题。而最小点覆盖和最大匹配的答案是一样的。所以直接通过模板求一边最大匹配的答案就可以得出结果了。

### 骑士放置

+ 这是一个 **最大独立集** 的问题。
+ **最大独立集** 的定义是 **选出最多的点使得选出的点之间没有边** 。
+ 最大团的定义是选出一个集合使得选出的点两两之间都有边
+ ![image-20210725135214332](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master//image-20210725135214332.png)
+ $最大独立集 = n - 最小点覆盖= n - 最大边匹配$
+ 所以这道题只需要求出二分图的最大匹配之后用总点数减去最小点覆盖中的点数量再减去不能放置的点的数量就可以。

## 欧拉路径和欧拉回路

+ 对有向图和无向图都有相关的性质。
+ 对于所有边都是联通的无向图
  1. 存在欧拉路径的充分必要条件：度数为奇数的点只能有0或2个。
  2. 欧拉回路是一种特殊的欧拉路径，其满足欧拉路径的性质且起点和终点是同一个点。存在欧拉回路的充分必要条件是度数为奇数的点只能有0个。
+ 对于所有边都是联通的有向图
  1. 存在欧拉路径的充分必要条件：要么所有点的出度均等于入度，要么除了两个点之外，其余所有点的出度等于入度，剩余的两个点：一个满足出度比入度多1（起点），另一个满足入度比出度多1
  2. 存在欧拉回路的充分必要条件：所有点的出度均等于入度

### 铲雪车

+ 这道题里面每加一次边都是给两个点均加上一个出度和一个入度。这样下来每个点的出度和入度都是一样的，存在欧拉回路。因此直接计算就可以，不需要建图。

### 欧拉回路

+ 这道题需要做一些奇怪的优化

### 骑马修栅栏

+ 在求欧拉路径的时候要注意最后求出来的是反过来的路径。如果正过来输出的话可以发现其实会是一个自环。只有反过来输出才是一个完整的路径。

  ```cpp
  #include <bits/stdc++.h>
  
  using namespace std;
  
  const int N = 3090;
  int g[N][N];
  int n;
  int res[N], cnt;
  int d[N];
  
  void dfs(int root)
  {
      for (int i = 1; i <= n; i ++ )
      {
          if (g[root][i])
          {
              g[root][i] -- , g[i][root] -- ;
              dfs(i);
          }
      }
      
      res[cnt ++ ] = root;
  }
  
  signed main()
  {
      cin >> n;
      for (int i = 0; i < n; i ++ ) 
      {
          int a, b;
          cin >> a >> b;
          g[a][b] ++ , g[b][a] ++ ;
          d[a] ++ , d[b] ++ ;
      }
      
      int root = 1;
      while (!d[root]) root ++ ;
      
      n = 500;
      
      for (int i = 1; i <= n; i ++ ) 
      {
          if (d[i] % 2)
          {
              root = i;
              break;
          }
      }
      
      dfs(root);
      
      for (int i = cnt - 1; i >= 0; i -- ) cout << res[i] << endl;
      
      return 0;
  }
  ```

  

### 单词游戏

+ 这道题可以把第一个字母当成起点，最后一个字母当成终点。总共的点数可以看成是26的点，可以看成是求一条路经过每一条边。也就是问我们这个有向图是否存在一个欧拉路径。
+ 这道题要判断的点有两个
  1. 是否存在欧拉路径
  2. 每个点是否联通
+ 判断每个点是否联通可以使用并查集。判断所有出现过的点是否在同一个集合中。如果不在同一个集合中的话则 `success = fals` 。

### 拓扑排序

+ 拓扑图 $DAG$ 就是有向无环图。
+ 步骤
  1. 将所有入度为0的点入队
  2. 当队列非空，每次取出队头元素，以此遍历其所有出边

### 奖金

+ ![image-20210727101544886](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master/image-20210727101544886.png)
+ 

# 高级数据结构

### 并查集

### 奇偶游戏

+ 

### 树状数组

+ 树状数组和线段树都可以用来求前缀和

+ 其主要操作如下

1. 快速求前缀和 $O(logn)$
2. 修改一个数 $O(logn)$ 

![image-20210520211310606](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master//image-20210520211310606.png)

+ 在树状数组中数组中每一个元素都代表 $[R-lowbit(R)+1,R]$ 这一段的元素的总和。
+ ![image-20201004235331837](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master//image-20201004235331837.png)

#### 楼兰图腾

+ 这道题很容易想到其朴素做法。从左往右扫一遍，每次扫到一个数字的时候将其左边以及右边再扫一遍，统计出其两边能和他组成 `V` 或者倒V的数字的个数，然后通过乘法原理乘起来。这样做的时间复杂度是 $O(n^2)$ 。但是我们很容易想到如果第一次扫的时候把左边大于他的数用树状数组记录下来，然后扫到这个元素的时候直接求出小于其的元素的个数之和，然后右边也是这样扫一遍，就能优化到 $0(nlogn)$ 的时间复杂度。因为扫一遍的时间复杂度是 $O(n)$ ，而在树状数组中求区间和的时间复杂度是 $O(logn)$ 。

+ 这里还要注意在更新 `res` 的时候要先转换为 `long long` 然后再加。因为如果不这样的话会先乘了再转换为 `long long` 。在乘的时候可能就会爆 `int` 。比如说返回的两个数都是 $10^9$ ，这时候如果先乘再转换为 `long long` 就绝对会溢出。

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  typedef long long ll;
  
  #define lowbit(x) ((x) & (-(x)))
  const int N = 200010;
  
  int a[N], tr[N];
  int gt[N], lower[N];
  int n;
  
  void add(int x, int v)
  {
      for (int i = x; i <= n; i += lowbit(i)) tr[i] += v;
  }
  
  int sum(int x)
  {
      int res = 0;
      for (int i = x; i; i -= lowbit(i)) res += tr[i];
      return res;
  }
  
  int main()
  {
      cin >> n;
      for (int i = 1; i <= n; i ++ ) cin >> a[i];
      
      for (int i = 1; i <= n; i ++ )
      {
          int y = a[i];
          gt[i] = sum(n) - sum(y);
          lower[i] = sum(y - 1);
          add(y, 1);
      }
      
      memset(tr, 0, sizeof tr);
      ll res1 = 0, res2 = 0;
      for (int i = n; i > 0; i -- )
      {
          int y = a[i];
          res1 += ((ll)gt[i] * ((ll)sum(n) - (ll)sum(y)));
          res2 += (lower[i] * (ll)sum(y - 1));
          add(y, 1);
      }
      
      cout << res1 << " " << res2; 
      
      return 0;
  }
  ```

#### 一个简单的整数问题

+ 这道题说要多次给一段数字都加上一个数。把数列中 $l\sim{r}$ 的元素每个都加上 $d$ 。很容易想到这里可以用到差分的方法。而在求某一个数的值的时候，需要将差分数组的 $1\sim n$ 的数全都加起来。如果用普通的差分数组的话这个操作的事件复杂度是 $O(n)$ 。因此很容易想到要用树状数组将时间复杂度优化为 $O(logn)$ 。在初始化整个树状数组的时候的时间复杂度是 $O(n)$ ，操作的事件复杂度是 $0(logn)$ ，总时间复杂度是 $max(O(n), O(mlogn))$ 。

  ```cpp
  #include <iostream>
  
  const int N = 100010;
  
  using namespace std;
  
  int tr[N], a[N];
  int n, m;
  
  int lowbit(int x)
  {
      return x & -x;
  }
  
  void add(int x, int v)
  {
      for (int i = x; i <= n; i += lowbit(i)) tr[i] += v;
  }
  
  int sum(int x)
  {
      int res = 0;
      for (int i = x; i; i -= lowbit(i)) res += tr[i];
      
      return res;
  }
  
  int main()
  {
      cin >> n >> m;
      for (int i = 1; i <= n; i ++ ) cin >> a[i];
      
      for (int i = 1; i <= n; i ++ ) add(i, a[i] - a[i - 1]);
  
      while (m -- )
      {
          char op[2];
          cin >> op;
          if (*op == 'Q')
          {
              int t;
              cin >> t;
              cout << sum(t) << endl;
          }
          else
          {
              int l, r, d;
              cin >> l >> r >> d;
              add(l, d), add(r + 1, -d);
          }
      }
      
      return 0;
  }
  ```

#### 一个简单的整数问题2

+ 维护区间的时候和上一题的思想类似，也是用树状数组维护一个差分数组。但是在需要区间和的时候则和上一题的思想不太相同。在上一题中，想要求出 $a[x]$ ，只需要求出差分数组中的 $\sum_{i=1}^{x}{b[i]}$ 。但是在这一题中，如果想要求出 $\sum_{i=l}^{r}a[i]$ 则需要求出 $\sum_{i=l}^{r}\sum_{j=1}^{i}b[j]$ 。需要进行两层循环。如果只是暴力按照之前的做法来做的话时间复杂度 $O(nmlogn)$ 是一定会超时的。

+ ![image-20210521113308033](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master//image-20210521113308033.png)

+ $\sum_{i=l}^{r}\sum_{j=1}^{i}b[j]$ 可以看成
  $$
  \begin{equation}       %开始数学环境
  \left(                 %左括号
    \begin{array}{ccc}  
      b1\\  %第一行元素
      b1 & b2 \\  %第二行元素
      b1 & b2 & b3\\
      b1 & b2 & b3 & b4\\
      ...
    \end{array}
  \right)                 %右括号
  \end{equation}
  $$
  这样一个矩阵。比如 $a[1]\sim{a[4]}$ 的区间和的矩阵如上图所示。但是这个矩阵不容易用代码求出来，，因此可以将其进行如下的填充
  $$
  \begin{equation}       %开始数学环境
  \left(                 %左括号
    \begin{array}{ccc}   %该矩阵一共3列，每一列都居中放置
      b1 & \textcolor{red}{b2} & \textcolor{red}{b3} & \textcolor{red}{b4} \\  %第一行元素
      b1 & b2 & \textcolor{red}{b3} & \textcolor{red}{b4} \\  %第二行元素
      b1 & b2 & b3 & \textcolor{red}{b4} \\
      b1 & b2 & b3 & b4\\
      ...
    \end{array}
  \right)                 %右括号
  \end{equation}
  $$
  这一个矩阵中每个元素的和就很好求得了。在求得总和之后再减去标红的元素的总和，就可以求得真正的 $a[l]\sim{a[r]}$ 的和。其公式如下

  $\sum_{i=l}^{r}\sum_{j=1}^{i}b[j]=\sum_{i=1}^{x}(x-i+1)\times{b[i]}=(x+1)\sum_{i=1}^x{b[i]}-\sum_{i=1}^{x}i\times{b[i]}$  

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  typedef long long ll;
  typedef long long LL;
  
  const int N = 100010;
  
  int n, m;
  ll tr1[N], tr2[N]; // tr1是b[i]的前缀和，tr2是b[i] * i的前缀和
  ll a[N];
  
  int lowbit(int x)
  {
      return x & -x;
  }
  
  void add(ll tr[], int x, ll v)
  {
      for (int i = x; i <= n; i += lowbit(i)) tr[i] += v;
  }
  
  ll sum(ll tr[], int x)
  {
      ll res = 0;
      for (int i = x; i; i -= lowbit(i)) res += tr[i];
      return res;
  }
  
  ll prefix_sum(int x)
  {
      return sum(tr1, x) * (x + 1) - sum(tr2, x);
  }
  
  int main()
  {
      cin >> n >> m;
      for (int i = 1; i <= n; i ++ ) cin >> a[i];
      
      for (int i = 1; i <= n; i ++ )
      {
          ll b = a[i] - a[i - 1];
          add(tr1, i, b);
          add(tr2, i, (ll)b * i);
      }
      
      while (m -- )
      {
          char op[2];
          cin >> op;
          int l, r, d;
          cin >> l >> r;
          if (*op == 'Q')
          {
              cout << prefix_sum(r) - prefix_sum(l - 1) << endl;
          }
          else
          {
              cin >> d;
              add(tr1, l, d), add(tr2, l, l * d);
              add(tr1, r + 1, -d), add(tr2, r + 1, (r + 1) * -d);
          }
      }
      
      return 0;
  }
  ```

#### 谜一样的牛

+ 在这一题中，最后一头牛前面有 $k$ 头比它高的牛就说明它是高度 $k+1$ 的牛。比如最后一头牛前面有2头比它高的牛，则说明其是第3高的牛。

+ 这道题可以从后往前遍历，把每一个身高如果被选中了设置为0，未被选中设置为1，这样我们可以通过求编号所对应的 **前缀和** 来确定这个编号前面还有几头比其还高的牛。而这个前缀和数组可以使用 **树状数组** 来优化为 $0(logn)$ 的时间复杂度，这样可以避免 $O(n^2)$ 时间复杂度导致超时的问题。

+ 在查找当前身高为 $k$ 的牛的身高应该为多少的时候可以用二分结合树状数组来做。

  ```cpp
  #include <iostream>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 1E5 + 10;
  int tr[N], a[N], ans[N];
  int n;
  
  int lowbit(int x)
  {
      return x & -x;
  }
  
  void add(int x, int v)
  {
      for (int i = x; i <= n; i += lowbit(i)) tr[i] += v;
  }
  
  int sum(int x)
  {
      int res = 0;
      for (int i = x; i; i -= lowbit(i)) res += tr[i];
      
      return res;
  }
  
  int main()
  {
      cin >> n;
      for (int i = 2; i <= n; i ++ ) cin >> a[i];
      for (int i = 1; i <= n; i ++ ) add(i, 1);
      
      for (int i = n; i; i -- )
      {
          int k = a[i] + 1;
          int l = 1, r = n;
          
          while (l < r)
          {
              int mid = l + r >> 1;
              if (k <= sum(mid)) r = mid;
              else l = mid + 1;
          }
  
          ans[i] = l;
          add(l, -1);
      }
      
      for (int i = 1; i <= n; i ++ ) cout << ans[i] << endl;
      
      return 0;
  }
  ```

### 线段树

+ 线段树在开空间的时候要开 `4 * n` 的空间。
+ 在划分的时候我们把一个区间 $[l,r]$ 划分为 $[l,mid]$ 和 $[mid+1,r]$ 。
+ 只涉及单点修改的话不需要用到懒标记。只有区间修改才可能会用到懒标记。

#### 你能回答这些问题吗

+ 

#### 一个简单的整数问题2

+ 

#### 维护序列

+ https://www.acwing.com/solution/content/9711/
+ ![image-20210811143414781](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed/image-20210811143414781.png)

### 可持久化数据结构

+ 可持久化的前提：本身的 **拓扑结构** 不会改变。比如线段树，其每个节点的两个儿子在整个过程中都是固定不变的。
+ 比如说平衡树这种，需要进行左旋和右旋的数据结构，其拓扑结构会发生改变，因此这样的数据结构就不能进行可持久化。
+ 可持久化解决的问题是要记录下所有修改的记录。也就是历史版本。类似于 `

#### 最大异或和

+ 

## 平衡树

#### 普通平衡树

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1E5 + 10, INF = 1E8;

#define DIE do\
{\
    cout << "出错了，行数" << __LINE__ << endl;\
    exit(0);\
} while (0)

struct Node
{
    int l, r;
    int key, val;
    int cnt;
    int size; // 这个节点的子树中数的个数（包括这个节点）
} tr[N];

int tree_root, idx;

void pushup(int root)
{
    tr[root].size = tr[tr[root].l].size + tr[tr[root].r].size + tr[root].cnt;
}

int get_node(int key)
{
    tr[ ++ idx].key = key;
    tr[idx].val = rand();
    tr[idx].cnt = tr[idx].size = 1;
    return idx;
}

void L(int &root)
{
    int temp = tr[root].r;
    tr[root].r = tr[temp].l;
    tr[temp].l = root;
    pushup(root);
    pushup(temp);
    root = temp;
}

void R(int &root)
{
    int temp = tr[root].l;
    tr[root].l = tr[temp].r;
    tr[temp].r = root;
    pushup(root);
    pushup(temp);
    root = temp;
}

void build()
{
    get_node(-INF), get_node(INF);
    tree_root = 1, tr[1].r = 2;
    pushup(tree_root);
    if (tr[1].val < tr[2].val) L(tree_root);
}

void insert(int &root, int key)
{
    if (!root) root = get_node(key);
    else if (tr[root].key == key) tr[root].cnt ++ ;
    else if (tr[root].key > key)
    {
        insert(tr[root].l, key);
        if (tr[tr[root].l].val > tr[root].val) R(root);
    }
    else if (tr[root].key < key)
    {
        insert(tr[root].r, key);
        if (tr[tr[root].r].val > tr[root].val) L(root);
    }
    else DIE;
    pushup(root);
}

void remove(int &root, int key)
{
    if (!root) return;
    if (tr[root].key == key) 
    {
        if (tr[root].cnt > 1) tr[root].cnt -- ;
        else if (tr[root].l || tr[root].r)
        {
            // 如果有左子树或者右子树，那么要将其往
            // 左边或者右边旋转到叶子节点再删除。
            // 这个操作因为和高度相关，因此时间复杂度是
            // O(logn)
            // 这里进行的判断是为了保持整颗树中的val的大根堆性质。
            // 如果左边的val比右边的大，那么通过右旋将其变为右子树的父亲。
            // 这样仍然可以保持正确的大根堆结构
            if (!tr[root].r || tr[tr[root].l].val > tr[tr[root].r].val)
            {
                R(root);
                remove(tr[root].r, key);
            }
            else 
            {
                L(root);
                remove(tr[root].l, key);
            }
        }
        else root = 0; // 如果是叶子节点，直接删除
    }
    else if (tr[root].key > key) remove(tr[root].l, key);
    else if (tr[root].key < key) remove(tr[root].r, key);
    else DIE;
    pushup(root);
}

int get_key_by_rank(int root, int rank)
{
    if (!root) return INF;
    if (tr[tr[root].l].size >= rank) return get_key_by_rank(tr[root].l, rank);
    if (tr[tr[root].l].size + tr[root].cnt >= rank) return tr[root].key;
    
    return get_key_by_rank(tr[root].r, rank - tr[root].cnt - tr[tr[root].l].size);
}

int get_rank_by_key(int root, int key)
{
    if (!root) return INF;
    if (tr[root].key == key) return tr[tr[root].l].size + 1;
    if (tr[root].key > key) return get_rank_by_key(tr[root].l, key);
    else if (tr[root].key < key) return tr[tr[root].l].size + tr[root].cnt + get_rank_by_key(tr[root].r, key);
    else DIE;
}

// 找到中序遍历的前驱，也就是小于这个数的
// 最大值。
// 如果当前数大于需要找的数，那么递归搜索当前节点的左子树
// 否则返回当前节点和当前节点的右子树中满足要求的
// 节点中的最大值
int get_prev(int root, int key)
{
    if (!root) return -INF;
    if (tr[root].key >= key) return get_prev(tr[root].l, key);
    
    return max(tr[root].key, get_prev(tr[root].r, key));
}

int get_next(int root, int key)
{
    if (!root) return INF;
    if (tr[root].key <= key) return get_next(tr[root].r, key);
    
    return min(tr[root].key, get_next(tr[root].l, key));
}

void dfs(int root)
{
    if (tr[root].l) dfs(tr[root].l);
    cout << tr[root].key << " ";
    if (tr[root].r) dfs(tr[root].r);
}

void show_tree()
{
    cout << "dfs(tree_root)" << endl;
    dfs(tree_root);

    cout << endl;
    
    for (int i = 1; i <= idx; i ++ ) 
    {
        printf("idx = %d, key = %d, val = %d l = %d, r = %d\n", i, tr[i].key, tr[i].val, tr[i].l, tr[i].r);
    }
}

#define show_tree();

//#undef ONLINE_JUDGE
#ifndef ONLINE_JUDGE
int max_depth;
void get_max_depth(int u, int depth)
{
    if (u == 0) return;
    max_depth = max(max_depth, depth);
    
    get_max_depth(tr[u].l, depth + 1);
    get_max_depth(tr[u].r, depth + 1);
}

// 测试看这个树是否满足堆的结构，很明显其实不满足。并不是一颗完全二叉树。其实treap只是通过rand得到的val来尽量随机地让这棵树平衡。如果不rand或者rand得到的值是单调递增或单调递减的，那么这棵树也会退化为一个链表。当然使用rand之后这样的事情并不会发生。
int q[N];
void test()
{
    get_max_depth(tree_root, 1);

    int hh = 0, tt = 0;
    q[0] = tree_root;
    
    int depth = 0;
    while (hh <= tt)
    {
        depth ++ ;
        int tail = tt;
        int head = hh;
        
        while (hh <= tail) 
        {
            auto t = q[hh ++ ];
            
            cout << tr[t].val << "(" << tr[t].key << ") ";
            //printf("%d(%d) ", tr[t].val, tr[t].key);
            //cout << tr[t].val << " ";
            q[ ++ tt] = tr[t].l, q[ ++ tt] = tr[t].r;
        }
        cout << endl;
        
        if (depth == max_depth) break;
    }
}
#endif

int main()
{
    srand(time(NULL));
    int T;
    cin >> T;
    
    build();
    show_tree();
    
    while (T -- )
    {
        int op, x;
        cin >> op >> x;
        
        show_tree();
        
        if (op == 1) insert(tree_root, x);
        else if (op == 2) remove(tree_root, x);
        else if (op == 3) cout << get_rank_by_key(tree_root, x) - 1 << endl;
        else if (op == 4) cout << get_key_by_rank(tree_root, x + 1) << endl;
        else if (op == 5) cout << get_prev(tree_root, x) << endl;
        else if (op == 6) cout << get_next(tree_root, x) << endl;
        else DIE;
    }
    
#ifndef ONLINE_JUDGE    
    cout << endl;
    test();
#endif
    
    return 0;
}
```

###  营业额统计

+ 这道题可以用 `stl` 中的 `set` 。
+ `set` 中的 `upper_bound` 函数返回指向首个*大于* `key` 的元素的迭代器， `lower_bound` 返回指向首个*不小于* `key` 的元素的迭代器。

## 可持久化数据结构

### 最长异或对

+ ![trie.001.jpeg](https://cdn.acwing.com/media/article/image/2021/04/24/8330_69574ea4a4-trie.001.jpeg)

  因为异或和可以通过前缀和来求出，所以我们可以将所有的异或前缀和放到一个 `trie` 树里面。然后在查询的时候只查询需要查询的 `l~r` 里面的前缀和的值和 $a[n]\bigoplus x$ 的最大异或对。那么这里我们就可以使用可持久化 `trie` 树来达到目的。

+ 每一次更新一个版本的时候都使用两个指针，一个从当前要插入的 `root[n]` 开始，一个从 `root[n - 1]` 开始。当前版本指针 `q` 每走一步，上一个版本的指针 `p`  也要走一步。如果发现上一个版本有另外的分支，那么也要让 `q` 指向那个分支。体现在代码中是

  ```cpp
  if (p) tr[q][v ^ 1] = tr[p][v ^ 1];
  ```

  这里其实并不需要判断另一个方向是否能走。因为如果不能走的话 `tr[p][v ^ 1]` 也会指向默认不能走的0。这样可以让当前版本可以到达之前的任意一个版本的任意一个点。其实相当于从 `root[i]` 这个点开始的这颗 `trie` 树其实就是 `1~i` 这些 `s[i]` 构成的一棵朴素的 `01trie` 。

+ 为了在查询的时候能够达到我们想要的效果，我们不能单纯只是每个版本的 `root` 不同。因为在查询的时候还有 `l` 的限制。这里为了满足这个限制，我们在建立每一个版本的 `trie` 树的时候我们需要将其进行更新。在每次到达最后一个节点的时候，我们要将其版本号 `max_id` （其实 `max_id` 表示的是当前点能到达的点的最大版本号）更新为当前版本的版本号。如下

  ```cpp
  if (k < 0)
  {
      max_id[q] = i;
      return;
  }
  ```

  而为了更新整颗树上的版本号，我们可以在递归的过程中于递归的最后通过左右子树能到达的最大版本号 `max_id` 来更新当前节点的 `max_id` 。代码如下

  ```cpp
  max_id[q] = max(max_id[tr[q][v]], max_id[tr[q][v ^ 1]]);
  ```

  而我们在进行查询 `query` 操作的时候则可以通过这个记录的 `max_id` 来确定我们能不能够走到我们需要的那个节点。为了让异或对的异或和最大，需要使走到的节点和当前的位的值不同。即走到的节点的值为 `v ^ 1` 的时候可以让结果最大。这里判断 `tr[p][v ^ 1]` 这个点的 `max_id` 是否符合 `query` 的规则，如果符合的话就往这边走 `p = tr[p][v ^ 1]` 。而如果不符合，那么只能走另外一条路 `p = tr[p][v]` 了。代码如下

  ```cpp
  if (max_id[tr[p][v ^ 1]] >= l) p = tr[p][v ^ 1];
  else p = tr[p][v];
  ```

  完整代码如下

  ```cpp
  #include <bits/stdc++.h>
  
  using namespace std;
  
  const int N = 600010, M = N * 25;
  
  int n, m;
  int s[N];
  int tr[M][2];
  int max_id[M];
  int root[N], idx;
  
  // i表示第i个插入的数i
  // k是当前到了第几位
  // p是上一个版本的指针
  // q是当前插入的版本的指针
  void insert(int i, int k, int p, int q)
  {
      if (k < 0)
      {
          max_id[q] = i;
          return;
      }
      
      // 取出需要用的那一位v
      int v = s[i] >> k & 1;
      
      // 如果上一个版本有另一个分支的话则指过去
      // 如果没有的话也不影响，因为如果没有的话就是0，影响不大
      if (p) tr[q][v ^ 1] = tr[p][v ^ 1];
      
      // 无论如何都要新开一个节点，在新开的节点里面
      // 如果需要指向旧的分支的话就指过去，如果不用的话
      // 就相当于trie树的正常插入
      tr[q][v] = ++ idx;
      
      insert(i, k - 1, tr[p][v], tr[q][v]);
      
      // 更新当前点的max_id（在子树已经结束后更新）
      // max_id用来保证遍历的时候不会跑到l之前的版本
      max_id[q] = max(max_id[tr[q][v]], max_id[tr[q][v ^ 1]]);
  }
  
  int query(int r, int C, int l)
  {
      int p = root[r];
      
      for (int i = 23; i >= 0; i -- ) 
      {
          int v = C >> i & 1;
          
          // 如果有不同的可以选，那么选不同的
          if (max_id[tr[p][v ^ 1]] >= l) p = tr[p][v ^ 1];
          else p = tr[p][v]; // 如果没有，那么只能选相同的
      }
      
      return C ^ s[max_id[p]];
  }
  
  signed main()
  {
      scanf("%d%d", &n, &m);
      
      // 用来标记当前点能到达的最大的版本（不太明白为什么要用这个）
      max_id[0] = -1;
      root[0] = ++ idx;
      
      // 首先把0插入到root为0的版本的树中
      insert(0, 23, 0, root[0]);
      
      for (int i = 1; i <= n; i ++ ) 
      {
          int x;
          scanf("%d", &x);
          s[i] = s[i - 1] ^ x;
          
          root[i] = ++ idx;
          insert(i, 23, root[i - 1], root[i]);
      }
      
      char op[2];
      int l, r, x;
      while (m -- ) 
      {
          scanf("%s", op);
          
          if (*op == 'A')
          {
              scanf("%d", &x);
              n ++ ;
              s[n] = s[n - 1] ^ x;
              root[n] = ++ idx;
              
              insert(n, 23, root[n - 1], root[n]);
          }
          else
          {
              scanf("%d%d%d", &l, &r, &x);
              printf("%d\n", query(r - 1, s[n] ^ x, l - 1));
          }
      }
      
      return 0;
  }
  ```


### 第K小数

+ 

## AC自动机

### 搜索关键词

+ AC自动机其实就是 `KMP` +  `TRIE` 。`KMP` 中 `next` 数组存的单纯是 **当前这个模式串中最长的前缀后缀匹配** ，但是在 `AC` 自动机中，存放的是对于 `trie` 树的当前位置的最长后缀所对应的前缀的那个尾端点。

# 基础算法

## 位运算

### 64位整数乘法

+ 龟速乘，时间复杂度是 $O(logn)$ ，但是可以不用写高精度。

## 前缀和与差分

### 递减序列

+ https://www.acwing.com/solution/content/5060/

+ 首先求出差分序列，可以看出只要 `b[2]~b[n]` 都等于0的话则把这个差分序列求前缀和后得到的原序列是一个 `a[1]~a[n]` 都相等的序列。而每次操作相当于在差分序列中选择两个元素，一个加一一个减一。那么我们求出这个差分序列中负数的和的abs `p` 和正数的和的abs `q`  ，我们要进行的操作次数就是 `max(p, q)` 。

+ 对于操作的种类，可以知道进行 `min(p, q)` 次操作之后 `b[2]~b[n]` 中全为正数或者全为负数，且 $abs(这些元素的和)=|p - q|$​ 。我们在操作这些元素使之全部变为0的过程中可以修改 $0\sim|p-q|$​​ 次 `b[1]` ，剩余次数修改 `b[n + 1]` 。可以知道操作的种类是 $|p-q|+1$​​ 。

  ```cpp
  #include <bits/stdc++.h>
  
  using namespace std;
  
  const int N = 1E5 + 10;
  
  #define int long long
  
  int n;
  int b[N];
  
  void insert(int l, int r, int v)
  {
      b[l] += v;
      b[r + 1] -= v;
  }
  
  signed main()
  {
      cin >> n;
      for (int i = 1; i <= n; i ++ )
      {
          int t;
          cin >> t;
          insert(i, i, t);
      }
      
      int p = 0, q = 0;
      for (int i = 2; i <= n; i ++ ) 
          if (b[i] > 0) p += b[i];
          else q += abs(b[i]);
          
      cout << max(p, q) << endl;
      cout << abs(p - q) + 1 << endl;
      
      return 0;
  }
  ```

## 二分

### 最佳牛围栏

+ 二分选择一个值，使得存在一个序列让其平均值大于等于 `avg` 。

## 排序

### 动态中位数

#### 无内鬼，来点平衡树
```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 10010, INF = 1E8;


#define DIE do\
{\
    cout << "出错了，行数" << __LINE__ << endl;\
    exit(0);\
} while (0)

struct Node
{
    int l, r;
    int key, val;
    int cnt;
    int size; // 这个节点的子树中数的个数（包括这个节点）
} tr[N];

int tree_root, idx;

void pushup(int root)
{
    tr[root].size = tr[tr[root].l].size + tr[tr[root].r].size + tr[root].cnt;
}

int get_node(int key)
{
    tr[ ++ idx].key = key;
    tr[idx].val = rand();
    tr[idx].cnt = tr[idx].size = 1;
    return idx;
}

void L(int &root)
{
    int temp = tr[root].r;
    tr[root].r = tr[temp].l;
    tr[temp].l = root;
    pushup(root);
    pushup(temp);
    root = temp;
}

void R(int &root)
{
    int temp = tr[root].l;
    tr[root].l = tr[temp].r;
    tr[temp].r = root;
    pushup(root);
    pushup(temp);
    root = temp;
}

void build()
{
    get_node(-INF), get_node(INF);
    tree_root = 1, tr[1].r = 2;
    pushup(tree_root);
    if (tr[1].val < tr[2].val) L(tree_root);
}

void insert(int &root, int key)
{
    if (!root) root = get_node(key);
    else if (tr[root].key == key) tr[root].cnt ++ ;
    else if (tr[root].key > key)
    {
        insert(tr[root].l, key);
        if (tr[tr[root].l].val > tr[root].val) R(root);
    }
    else if (tr[root].key < key)
    {
        insert(tr[root].r, key);
        if (tr[tr[root].r].val > tr[root].val) L(root);
    }
    else DIE;
    pushup(root);
}

void remove(int &root, int key)
{
    if (!root) return;
    if (tr[root].key == key) 
    {
        if (tr[root].cnt > 1) tr[root].cnt -- ;
        else if (tr[root].l || tr[root].r)
        {
            // 如果有左子树或者右子树，那么要将其往
            // 左边或者右边旋转到叶子节点再删除。
            // 这个操作因为和高度相关，因此时间复杂度是
            // O(logn)
            // 这里进行的判断是为了保持整颗树中的val的大根堆性质。
            // 如果左边的val比右边的大，那么通过右旋将其变为右子树的父亲。
            // 这样仍然可以保持正确的大根堆结构
            if (!tr[root].r || tr[tr[root].l].val > tr[tr[root].r].val)
            {
                R(root);
                remove(tr[root].r, key);
            }
            else 
            {
                L(root);
                remove(tr[root].l, key);
            }
        }
        else root = 0; // 如果是叶子节点，直接删除
    }
    else if (tr[root].key > key) remove(tr[root].l, key);
    else if (tr[root].key < key) remove(tr[root].r, key);
    else DIE;
    pushup(root);
}

int get_key_by_rank(int root, int rank)
{
    if (!root) return INF;
    if (tr[tr[root].l].size >= rank) return get_key_by_rank(tr[root].l, rank);
    if (tr[tr[root].l].size + tr[root].cnt >= rank) return tr[root].key;

    return get_key_by_rank(tr[root].r, rank - tr[root].cnt - tr[tr[root].l].size);
}

int get_rank_by_key(int root, int key)
{
    if (!root) return INF;
    if (tr[root].key == key) return tr[tr[root].l].size + 1;
    if (tr[root].key > key) return get_rank_by_key(tr[root].l, key);
    else if (tr[root].key < key) return tr[tr[root].l].size + tr[root].cnt + get_rank_by_key(tr[root].r, key);
    else DIE;
}

// 找到中序遍历的前驱，也就是小于这个数的
// 最大值。
// 如果当前数大于需要找的数，那么递归搜索当前节点的左子树
// 否则返回当前节点和当前节点的右子树中满足要求的
// 节点中的最大值
int get_prev(int root, int key)
{
    if (!root) return -INF;
    if (tr[root].key >= key) return get_prev(tr[root].l, key);

    return max(tr[root].key, get_prev(tr[root].r, key));
}

int get_next(int root, int key)
{
    if (!root) return INF;
    if (tr[root].key <= key) return get_next(tr[root].r, key);

    return min(tr[root].key, get_next(tr[root].l, key));
}

void init()
{
    srand(time(NULL));
    memset(tr, 0, sizeof tr);
    idx = 0;
    build();
}

signed main()
{
    int T;
    cin >> T;
    
    while (T -- )
    {
        init();
        int n, m;
        cin >> m >> n;
        cout << m << " " << (n + 1) / 2 << endl;
        
        int cnt = 0;
        for (int i = 1; i <= n; i ++ ) 
        {
            int t;
            cin >> t;
            insert(tree_root, t);
            
            if (i % 2)
            {
                cout << get_key_by_rank(tree_root, (i + 1) / 2 + 1) << " ";
                cnt ++ ;
                if (cnt % 10 == 0) cout << endl;
            }
        }
        
        if (cnt % 10) cout << endl;
    }
    
    return 0;
}
```
#### 对顶堆做法
```cpp
#include <bits/stdc++.h>

using namespace std;

int main()
{
    int T;
    cin >> T;
    
    while (T -- )
    {
        int n, m;
        cin >> m >> n;
        cout << m << " " << (n + 1) / 2 << endl;
        
        priority_queue<int> down;
        priority_queue<int, vector<int>, greater<int> > up;
        
        int cnt = 0;
        for (int i = 1; i <= n; i ++ ) 
        {
            int t;
            cin >> t;
            
            if (down.empty() || t <= down.top()) down.push(t);
            else up.push(t);
            if (down.size() > up.size() + 1) up.push(down.top()), down.pop();
            else if (up.size() > down.size()) down.push(up.top()), up.pop();
            
            if (i % 2) 
            {
                cout << down.top() << " ";
                cnt ++ ;
                if (cnt % 10 == 0) cout << endl;
            }
        }
        
        if (cnt % 10) cout << endl;
    }
    
    return 0;
}
```

## RMQ

### 天才的记忆

+ 计算 $log_2^k$ 可以通过换底公式。

  ![image-20210817130809151](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed/image-20210817130809151.png)

+ 即 $log_2^k=log_e^k \div log_e^2$ 。而要取向下取整的话直接将其转换为 `int` 即可向下取整。

+ `st` 表中 `f[i][j]` 表示从 `i` 开始，长度为 $2^j$ 的区间的最大值。这个表可以通过动态规划得出。 

  $f(i,0)=w[i]$

  $f(i,j)=max(f(i, j -1), f(i + {2^{j-1}},j-1))$ 。

+ 在求得 `st` 表后可以发现，每次询问可以变成这样

+ ![image-20210817132520216](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed/image-20210817132520216.png)

  这样通过 `st` 表求出两个全部在 `l~r` 中的区间的最大值，这两个区间的最大值即为 `l~r` 中的最大值。

  