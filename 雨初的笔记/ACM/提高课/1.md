## 搜索

### A star

#### 第k短路

+ `
+ `A*` 问题的核心思想是： **在BFS中，如果所有边权都是非负的，那么就可以用启发函数来优化BFS过程** 。
+ `dijkstra` 算法可以用数学归纳法和反证法来证明：
  + 如果有一个 `s` 点，当前 `st[s] = true` ，有 `t` 点可以走到 `s` 点。因为 `dist[s] <= dist[t]` ，因此如果再 `dist[t] + s->t` ，也不可能让 `dist[s]` 更小。得证。
+ ![image-20210517211459273](C:\Users\雨初\AppData\Roaming\Typora\typora-user-images\image-20210517211459273.png)

#### 八数码

+ 八数码问题无解当且仅当 **逆序对数量是奇数** 。如果是偶数则一定有解。
+ `A*` 算法的主要思想就是把当前点到终点的距离更新为 `dist[i] + f(i)` ，其中 `f(i)` 要小于等于真实距离。

#### 矩阵距离

+ 这道题可以把所有为1的点放到队列里面，然后多元开始宽搜。搜完了之后每一个点是在第几层被搜到的就证明其到最近的1的最短距离。
+ 因为是宽搜，每个点最多只能被搜到一次，因此时间复杂度是 $0(n)$ 的。
+ 写bfs的时候有一个技巧，不用设置st数组，直接给dist数组设置一个特殊的初始值，如果得到的值是这个数字就说明其没有进入过队列。这样可以省下一个数组的空间开销。

#### 电路维修

+ 在更新了边权之后，如果当前路的长度为0，那么dist和原来的一样，那么这个就不能推入到队列的末尾中。因为在 `bfs` 的时候整个队列需要保证 **两端性和单调性** 。如果让dist没有增加的点放到最后，势必会破坏整个队列的单调性。

#### 字串变换

+ 双向广搜一般用在 **最小步数** 问题中。在最短路、flood fill问题中一般用不到。
+ 在扩展的时候一定有一边的可能状态多，一边的可能状态少。在扩展的时候每次都应该选择状态少的一边进行扩展（在这道题里面是字符串长度较短）。这样可以保证时间空间用得最少。

## 图论

+ 所有的最小生成树，prim或kruskal，都是无向边。

#### 局域网

+ 相当于在每一个块中求一颗生成树。相当于求一个”生成森林“。
+ 这道题说要求删去的边权和最大的，也就是说求剩下的边权和最小的。因此可以求出每个联通块的最小生成树，求出的这个最小生成树组成的森林就是最后生下来的图。

#### 繁忙的都市

## 高级数据结构

### 树状数组

+ 其主要操作如下

1. 快速求前缀和 $O(logn)$
2. 修改一个数 $O(logn)$ 

![image-20210520211310606](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master//image-20210520211310606.png)

+ 在树状数组中数组中每一个元素都代表 $[R-lowbit(R)+1,R]$ 这一段的元素的总和。
+ ![image-20201004235331837](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master//image-20201004235331837.png)

#### 楼兰图腾

+ 这道题很容易想到其朴素做法。从左往右扫一遍，每次扫到一个数字的时候将其左边以及右边再扫一遍，统计出其两边能和他组成 `V` 或者倒V的数字的个数，然后通过乘法原理乘起来。这样做的时间复杂度是 $O(n^2)$ 。但是我们很容易想到如果第一次扫的时候把左边大于他的数用树状数组记录下来，然后扫到这个元素的时候直接求出小于其的元素的个数之和，然后右边也是这样扫一遍，就能优化到 $0(nlogn)$ 的时间复杂度。因为扫一遍的时间复杂度是 $O(n)$ ，而在树状数组中求区间和的时间复杂度是 $O(logn)$ 。

+ 这里还要注意在更新 `res` 的时候要先转换为 `long long` 然后再加。因为如果不这样的话会先乘了再转换为 `long long` 。在乘的时候可能就会爆 `int` 。比如说返回的两个数都是 $10^9$ ，这时候如果先乘再转换为 `long long` 就绝对会溢出。

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  typedef long long ll;
  
  #define lowbit(x) ((x) & (-(x)))
  const int N = 200010;
  
  int a[N], tr[N];
  int gt[N], lower[N];
  int n;
  
  void add(int x, int v)
  {
      for (int i = x; i <= n; i += lowbit(i)) tr[i] += v;
  }
  
  int sum(int x)
  {
      int res = 0;
      for (int i = x; i; i -= lowbit(i)) res += tr[i];
      return res;
  }
  
  int main()
  {
      cin >> n;
      for (int i = 1; i <= n; i ++ ) cin >> a[i];
      
      for (int i = 1; i <= n; i ++ )
      {
          int y = a[i];
          gt[i] = sum(n) - sum(y);
          lower[i] = sum(y - 1);
          add(y, 1);
      }
      
      memset(tr, 0, sizeof tr);
      ll res1 = 0, res2 = 0;
      for (int i = n; i > 0; i -- )
      {
          int y = a[i];
          res1 += ((ll)gt[i] * ((ll)sum(n) - (ll)sum(y)));
          res2 += (lower[i] * (ll)sum(y - 1));
          add(y, 1);
      }
      
      cout << res1 << " " << res2; 
      
      return 0;
  }
  ```

#### 一个简单的整数问题

+ 这道题说要多次给一段数字都加上一个数。把数列中 $l\sim{r}$ 的元素每个都加上 $d$ 。很容易想到这里可以用到差分的方法。而在求某一个数的值的时候，需要将差分数组的 $1\sim n$ 的数全都加起来。如果用普通的差分数组的话这个操作的事件复杂度是 $O(n)$ 。因此很容易想到要用树状数组将时间复杂度优化为 $O(logn)$ 。在初始化整个树状数组的时候的时间复杂度是 $O(n)$ ，操作的事件复杂度是 $0(logn)$ ，总时间复杂度是 $max(O(n), O(mlogn))$ 。

  ```cpp
  #include <iostream>
  
  const int N = 100010;
  
  using namespace std;
  
  int tr[N], a[N];
  int n, m;
  
  int lowbit(int x)
  {
      return x & -x;
  }
  
  void add(int x, int v)
  {
      for (int i = x; i <= n; i += lowbit(i)) tr[i] += v;
  }
  
  int sum(int x)
  {
      int res = 0;
      for (int i = x; i; i -= lowbit(i)) res += tr[i];
      
      return res;
  }
  
  int main()
  {
      cin >> n >> m;
      for (int i = 1; i <= n; i ++ ) cin >> a[i];
      
      for (int i = 1; i <= n; i ++ ) add(i, a[i] - a[i - 1]);
  
      while (m -- )
      {
          char op[2];
          cin >> op;
          if (*op == 'Q')
          {
              int t;
              cin >> t;
              cout << sum(t) << endl;
          }
          else
          {
              int l, r, d;
              cin >> l >> r >> d;
              add(l, d), add(r + 1, -d);
          }
      }
      
      return 0;
  }
  ```

  