## 搜索

### A star

#### 第k短路

+ `
+ `A*` 问题的核心思想是： **在BFS中，如果所有边权都是非负的，那么就可以用启发函数来优化BFS过程** 。
+ `dijkstra` 算法可以用数学归纳法和反证法来证明：
  + 如果有一个 `s` 点，当前 `st[s] = true` ，有 `t` 点可以走到 `s` 点。因为 `dist[s] <= dist[t]` ，因此如果再 `dist[t] + s->t` ，也不可能让 `dist[s]` 更小。得证。
+ ![image-20210517211459273](C:\Users\雨初\AppData\Roaming\Typora\typora-user-images\image-20210517211459273.png)

#### 八数码

+ 八数码问题无解当且仅当 **逆序对数量是奇数** 。如果是偶数则一定有解。
+ `A*` 算法的主要思想就是把当前点到终点的距离更新为 `dist[i] + f(i)` ，其中 `f(i)` 要小于等于真实距离。

#### 矩阵距离

+ 这道题可以把所有为1的点放到队列里面，然后多元开始宽搜。搜完了之后每一个点是在第几层被搜到的就证明其到最近的1的最短距离。
+ 因为是宽搜，每个点最多只能被搜到一次，因此时间复杂度是 $0(n)$ 的。
+ 写bfs的时候有一个技巧，不用设置st数组，直接给dist数组设置一个特殊的初始值，如果得到的值是这个数字就说明其没有进入过队列。这样可以省下一个数组的空间开销。

#### 电路维修

+ 在更新了边权之后，如果当前路的长度为0，那么dist和原来的一样，那么这个就不能推入到队列的末尾中。因为在 `bfs` 的时候整个队列需要保证 **两端性和单调性** 。如果让dist没有增加的点放到最后，势必会破坏整个队列的单调性。

#### 字串变换

+ 双向广搜一般用在 **最小步数** 问题中。在最短路、flood fill问题中一般用不到。
+ 在扩展的时候一定有一边的可能状态多，一边的可能状态少。在扩展的时候每次都应该选择状态少的一边进行扩展（在这道题里面是字符串长度较短）。这样可以保证时间空间用得最少。

## 图论

+ 所有的最小生成树，prim或kruskal，都是无向边。

#### 局域网

+ 相当于在每一个块中求一颗生成树。相当于求一个”生成森林“。
+ 这道题说要求删去的边权和最大的，也就是说求剩下的边权和最小的。因此可以求出每个联通块的最小生成树，求出的这个最小生成树组成的森林就是最后生下来的图。

#### 繁忙的都市

## 高级数据结构

### 树状数组

+ 树状数组和线段树都可以用来求前缀和

+ 其主要操作如下

1. 快速求前缀和 $O(logn)$
2. 修改一个数 $O(logn)$ 

![image-20210520211310606](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master//image-20210520211310606.png)

+ 在树状数组中数组中每一个元素都代表 $[R-lowbit(R)+1,R]$ 这一段的元素的总和。
+ ![image-20201004235331837](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master//image-20201004235331837.png)

#### 楼兰图腾

+ 这道题很容易想到其朴素做法。从左往右扫一遍，每次扫到一个数字的时候将其左边以及右边再扫一遍，统计出其两边能和他组成 `V` 或者倒V的数字的个数，然后通过乘法原理乘起来。这样做的时间复杂度是 $O(n^2)$ 。但是我们很容易想到如果第一次扫的时候把左边大于他的数用树状数组记录下来，然后扫到这个元素的时候直接求出小于其的元素的个数之和，然后右边也是这样扫一遍，就能优化到 $0(nlogn)$ 的时间复杂度。因为扫一遍的时间复杂度是 $O(n)$ ，而在树状数组中求区间和的时间复杂度是 $O(logn)$ 。

+ 这里还要注意在更新 `res` 的时候要先转换为 `long long` 然后再加。因为如果不这样的话会先乘了再转换为 `long long` 。在乘的时候可能就会爆 `int` 。比如说返回的两个数都是 $10^9$ ，这时候如果先乘再转换为 `long long` 就绝对会溢出。

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  typedef long long ll;
  
  #define lowbit(x) ((x) & (-(x)))
  const int N = 200010;
  
  int a[N], tr[N];
  int gt[N], lower[N];
  int n;
  
  void add(int x, int v)
  {
      for (int i = x; i <= n; i += lowbit(i)) tr[i] += v;
  }
  
  int sum(int x)
  {
      int res = 0;
      for (int i = x; i; i -= lowbit(i)) res += tr[i];
      return res;
  }
  
  int main()
  {
      cin >> n;
      for (int i = 1; i <= n; i ++ ) cin >> a[i];
      
      for (int i = 1; i <= n; i ++ )
      {
          int y = a[i];
          gt[i] = sum(n) - sum(y);
          lower[i] = sum(y - 1);
          add(y, 1);
      }
      
      memset(tr, 0, sizeof tr);
      ll res1 = 0, res2 = 0;
      for (int i = n; i > 0; i -- )
      {
          int y = a[i];
          res1 += ((ll)gt[i] * ((ll)sum(n) - (ll)sum(y)));
          res2 += (lower[i] * (ll)sum(y - 1));
          add(y, 1);
      }
      
      cout << res1 << " " << res2; 
      
      return 0;
  }
  ```

#### 一个简单的整数问题

+ 这道题说要多次给一段数字都加上一个数。把数列中 $l\sim{r}$ 的元素每个都加上 $d$ 。很容易想到这里可以用到差分的方法。而在求某一个数的值的时候，需要将差分数组的 $1\sim n$ 的数全都加起来。如果用普通的差分数组的话这个操作的事件复杂度是 $O(n)$ 。因此很容易想到要用树状数组将时间复杂度优化为 $O(logn)$ 。在初始化整个树状数组的时候的时间复杂度是 $O(n)$ ，操作的事件复杂度是 $0(logn)$ ，总时间复杂度是 $max(O(n), O(mlogn))$ 。

  ```cpp
  #include <iostream>
  
  const int N = 100010;
  
  using namespace std;
  
  int tr[N], a[N];
  int n, m;
  
  int lowbit(int x)
  {
      return x & -x;
  }
  
  void add(int x, int v)
  {
      for (int i = x; i <= n; i += lowbit(i)) tr[i] += v;
  }
  
  int sum(int x)
  {
      int res = 0;
      for (int i = x; i; i -= lowbit(i)) res += tr[i];
      
      return res;
  }
  
  int main()
  {
      cin >> n >> m;
      for (int i = 1; i <= n; i ++ ) cin >> a[i];
      
      for (int i = 1; i <= n; i ++ ) add(i, a[i] - a[i - 1]);
  
      while (m -- )
      {
          char op[2];
          cin >> op;
          if (*op == 'Q')
          {
              int t;
              cin >> t;
              cout << sum(t) << endl;
          }
          else
          {
              int l, r, d;
              cin >> l >> r >> d;
              add(l, d), add(r + 1, -d);
          }
      }
      
      return 0;
  }
  ```

#### 一个简单的整数问题2

+ 维护区间的时候和上一题的思想类似，也是用树状数组维护一个差分数组。但是在需要区间和的时候则和上一题的思想不太相同。在上一题中，想要求出 $a[x]$ ，只需要求出差分数组中的 $\sum_{i=1}^{x}{b[i]}$ 。但是在这一题中，如果想要求出 $\sum_{i=l}^{r}a[i]$ 则需要求出 $\sum_{i=l}^{r}\sum_{j=1}^{i}b[j]$ 。需要进行两层循环。如果只是暴力按照之前的做法来做的话时间复杂度 $O(nmlogn)$ 是一定会超时的。

+ ![image-20210521113308033](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master//image-20210521113308033.png)

+ $\sum_{i=l}^{r}\sum_{j=1}^{i}b[j]$ 可以看成
  $$
  \begin{equation}       %开始数学环境
  \left(                 %左括号
    \begin{array}{ccc}  
      b1\\  %第一行元素
      b1 & b2 \\  %第二行元素
      b1 & b2 & b3\\
      b1 & b2 & b3 & b4\\
      ...
    \end{array}
  \right)                 %右括号
  \end{equation}
  $$
  这样一个矩阵。比如 $a[1]\sim{a[4]}$ 的区间和的矩阵如上图所示。但是这个矩阵不容易用代码求出来，，因此可以将其进行如下的填充
  $$
  \begin{equation}       %开始数学环境
  \left(                 %左括号
    \begin{array}{ccc}   %该矩阵一共3列，每一列都居中放置
      b1 & \textcolor{red}{b2} & \textcolor{red}{b3} & \textcolor{red}{b4} \\  %第一行元素
      b1 & b2 & \textcolor{red}{b3} & \textcolor{red}{b4} \\  %第二行元素
      b1 & b2 & b3 & \textcolor{red}{b4} \\
      b1 & b2 & b3 & b4\\
      ...
    \end{array}
  \right)                 %右括号
  \end{equation}
  $$
  这一个矩阵中每个元素的和就很好求得了。在求得总和之后再减去标红的元素的总和，就可以求得真正的 $a[l]\sim{a[r]}$ 的和。其公式如下

  $\sum_{i=l}^{r}\sum_{j=1}^{i}b[j]=\sum_{i=1}^{x}(x-i+1)\times{b[i]}=(x+1)\sum_{i=1}^x{b[i]}-\sum_{i=1}^{x}i\times{b[i]}$  

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  typedef long long ll;
  typedef long long LL;
  
  const int N = 100010;
  
  int n, m;
  ll tr1[N], tr2[N]; // tr1是b[i]的前缀和，tr2是b[i] * i的前缀和
  ll a[N];
  
  int lowbit(int x)
  {
      return x & -x;
  }
  
  void add(ll tr[], int x, ll v)
  {
      for (int i = x; i <= n; i += lowbit(i)) tr[i] += v;
  }
  
  ll sum(ll tr[], int x)
  {
      ll res = 0;
      for (int i = x; i; i -= lowbit(i)) res += tr[i];
      return res;
  }
  
  ll prefix_sum(int x)
  {
      return sum(tr1, x) * (x + 1) - sum(tr2, x);
  }
  
  int main()
  {
      cin >> n >> m;
      for (int i = 1; i <= n; i ++ ) cin >> a[i];
      
      for (int i = 1; i <= n; i ++ )
      {
          ll b = a[i] - a[i - 1];
          add(tr1, i, b);
          add(tr2, i, (ll)b * i);
      }
      
      while (m -- )
      {
          char op[2];
          cin >> op;
          int l, r, d;
          cin >> l >> r;
          if (*op == 'Q')
          {
              cout << prefix_sum(r) - prefix_sum(l - 1) << endl;
          }
          else
          {
              cin >> d;
              add(tr1, l, d), add(tr2, l, l * d);
              add(tr1, r + 1, -d), add(tr2, r + 1, (r + 1) * -d);
          }
      }
      
      return 0;
  }
  ```

#### 谜一样的牛

+ 在这一题中，最后一头牛前面有 $k$ 头比它高的牛就说明它是高度 $k+1$ 的牛。比如最后一头牛前面有2头比它高的牛，则说明其是第3高的牛。

+ 这道题可以从后往前遍历，把每一个身高如果被选中了设置为0，未被选中设置为1，这样我们可以通过求编号所对应的 **前缀和** 来确定这个编号前面还有几头比其还高的牛。而这个前缀和数组可以使用 **树状数组** 来优化为 $0(logn)$ 的时间复杂度，这样可以避免 $O(n^2)$ 时间复杂度导致超时的问题。

+ 在查找当前身高为 $k$ 的牛的身高应该为多少的时候可以用二分结合树状数组来做。

  ```cpp
  #include <iostream>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 1E5 + 10;
  int tr[N], a[N], ans[N];
  int n;
  
  int lowbit(int x)
  {
      return x & -x;
  }
  
  void add(int x, int v)
  {
      for (int i = x; i <= n; i += lowbit(i)) tr[i] += v;
  }
  
  int sum(int x)
  {
      int res = 0;
      for (int i = x; i; i -= lowbit(i)) res += tr[i];
      
      return res;
  }
  
  int main()
  {
      cin >> n;
      for (int i = 2; i <= n; i ++ ) cin >> a[i];
      for (int i = 1; i <= n; i ++ ) add(i, 1);
      
      for (int i = n; i; i -- )
      {
          int k = a[i] + 1;
          int l = 1, r = n;
          
          while (l < r)
          {
              int mid = l + r >> 1;
              if (k <= sum(mid)) r = mid;
              else l = mid + 1;
          }
  
          ans[i] = l;
          add(l, -1);
      }
      
      for (int i = 1; i <= n; i ++ ) cout << ans[i] << endl;
      
      return 0;
  }
  ```

### 线段树

+ 线段树在开空间的时候要开 `4 * n` 的空间。
+ 在划分的时候我们把一个区间 $[l,r]$ 划分为 $[l,mid]$ 和 $[mid+1,r]$ 。
+ 为什么 `pushup` 的时候不用一直递归更新到顶层呢，只更新一层是否会导致上面的数据不正确？ 

#### 你能回答这些问题吗

+ 