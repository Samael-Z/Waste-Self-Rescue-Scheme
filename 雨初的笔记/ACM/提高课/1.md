## 搜索

### A star

#### 第k短路

+ `A*` 问题的核心思想是： **在BFS中，如果所有边权都是非负的，那么就可以用启发函数来优化BFS过程** 。
+ `dijkstra` 算法可以用数学归纳法和反证法来证明：
  + 如果有一个 `s` 点，当前 `st[s] = true` ，有 `t` 点可以走到 `s` 点。因为 `dist[s] <= dist[t]` ，因此如果再 `dist[t] + s->t` ，也不可能让 `dist[s]` 更小。得证。
+ ![image-20210630145141727](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master//image-20210630145141727.png)

#### 八数码

+ 八数码问题无解当且仅当 **逆序对数量是奇数** 。如果是偶数则一定有解。
+ `A*` 算法的主要思想就是把当前点到终点的距离更新为 `dist[i] + f(i)` ，其中 `f(i)` 要小于等于真实距离。

#### 矩阵距离

+ 这道题可以把所有为1的点放到队列里面，然后多元开始宽搜。搜完了之后每一个点是在第几层被搜到的就证明其到最近的1的最短距离。
+ 因为是宽搜，每个点最多只能被搜到一次，因此时间复杂度是 $0(n)$ 的。
+ 写bfs的时候有一个技巧，不用设置st数组，直接给dist数组设置一个特殊的初始值，如果得到的值是这个数字就说明其没有进入过队列。这样可以省下一个数组的空间开销。

#### 电路维修

+ 在更新了边权之后，如果当前路的长度为0，那么dist和原来的一样，那么这个就不能推入到队列的末尾中。因为在 `bfs` 的时候整个队列需要保证 **两端性和单调性** 。如果让dist没有增加的点放到最后，势必会破坏整个队列的单调性。

#### 字串变换

+ 双向广搜一般用在 **最小步数** 问题中。在最短路、flood fill问题中一般用不到。
+ 在扩展的时候一定有一边的可能状态多，一边的可能状态少。在扩展的时候每次都应该选择状态少的一边进行扩展（在这道题里面是字符串长度较短）。这样可以保证时间空间用得最少。


### 马走日

+ 这道题是一个外部搜索

+ 每次搜索结束之后恢复现场。

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 110;
  
  bool st[N][N];
  
  int n, m;
  int ans;
  
  int dx[] = {1, 1, -1, -1, 2, 2, -2, -2};
  int dy[] = {2, -2, 2, -2, 1, -1, 1, -1};
  
  void dfs(int x, int y, int cnt)
  {
      if (cnt == n * m)
      {
          ans ++ ;
          return;
      }
      
      st[x][y] = true;
      
      for (int i = 0; i < 8; i ++ )
      {
          int tx = x + dx[i];
          int ty = y + dy[i];
          
          if (tx < 0 || ty < 0 || tx >= n || ty >= m) continue;
          if (st[tx][ty]) continue;
          
          dfs(tx, ty, cnt + 1);
      }
      
      st[x][y] = false;
  }
  
  int main()
  {
      int T;
      cin >> T;
      
      while (T -- )
      {
          ans = 0;
          
          int x, y;
          cin >> n >> m >> x >> y;
          
          dfs(x, y, 1);
          
          cout << ans << endl;
      }
      
      return 0;
  }
  ```


### 单词接龙

+ 这也是一个外部搜索，每次搜索到不同的状态之后要将状态进行还原。

+ 首先预处理一遍把所有的字符串两两对应的重合部分算出来，然后进行外部搜索。每次搜索的时候遍历所有字符串，如果发现有可以继续下去并且使用次数少于2的就接上龙继续dfs下去，在dfs结束之后 `used[last] -- ` 恢复现场。

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  #include <string>
  #include <string.h>
  
  using namespace std;
  
  const int N = 110;
  
  string word[N];
  int n;
  int used[N];
  int g[N][N];
  int ans;
  
  void dfs(string dragon, int last)
  {
      ans = max((int)dragon.size(), ans);
      
      used[last] ++ ;
      
      for (int i = 0; i < n; i ++ )
      {
          if (g[last][i] && used[i] < 2)
              dfs(dragon + word[i].substr(g[last][i]), i);
      }
      
      used[last] -- ;
  }
  
  int main()
  {
      cin >> n;
      for (int i = 0; i < n; i ++ ) cin >> word[i];
      
      char start;
      cin >> start;
      
      for (int i = 0; i < n; i ++ )
          for (int j = 0; j < n; j ++ )
          {
              string a = word[i], b = word[j];
              for (int k = 1; k < min(a.size(), b.size()); k ++ )
                  if (a.substr(a.size() - k) == b.substr(0, k))
                  {
                      g[i][j] = k;
                      break;
                  }
          }
          
      for (int i = 0; i < n; i ++ )
          if (word[i][0] == start)
              dfs(word[i], i);
              
              
      cout << ans << endl;
      
      return 0;
  }
  ```

### 分成互质组

+ 如果当前的组里面能放下新的数，一定不能新开一个组。因为如果新开一个组能得到最优解的话，那么把这个数放回到原来的那个能放这个数的组里面也是最优解（？）

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 10;
  
  int p[N];
  int group[N][N];
  int ans = N;
  bool st[N];
  int n;
  
  int gcd(int a, int b)
  {
      return b ? gcd(b, a % b) : a;
  }
  
  // 判断i下标的数和这个组中的元素是不是全部互质
  bool check(int group[], int gc, int i)
  {
      for (int j = 0; j < gc; j ++ )
          if (gcd(p[group[j]], p[i]) > 1)
              return false;
              
      return true;
  }
  
  // u表示当前遍历到第几个组，gc表示当前组内的下标
  // tc表示当前遍历到第几个元素（一共有几个元素）
  // start表示当前可以从哪个元素开始搜（？tc和start不重复吗）
  void dfs(int u, int gc, int tc, int start)
  {
      // 说明不是最优解
      if (u >= ans) return;
      if (tc == n) ans = u; // 为什么不return？
      
      bool flag = true;
      for (int i = start; i < n; i ++ )
      {
          // 如果这个数没有被用过而且第i个元素与其是互质的
          // 那么可以用这个数
          if (!st[i] && check(group[u], gc, i))
          {
              st[i] = true;
              group[u][gc] = i;
              
              dfs(u, gc + 1, tc + 1, i + 1);
              
              st[i] = false;
              
              flag = false;
          }
      }
      
      // 如果不能添加到任何一个已有的组中
      if (flag) dfs(u + 1, 0, tc, 0);
  }
  
  int main()
  {
      cin >> n;
      
      for (int i = 0; i < n; i ++ ) cin >> p[i];
      
      dfs(1, 0, 0, 0);
      
      cout << ans << endl;
      
      return 0;
  }
  ```

### 小猫爬山

+ 这道题看起来像是背包，但是w和c都异常地大，不是背包问题。要爆搜，但是要注意剪枝否则tle

+ 这道题一共有两种决策。

  1. 放到一个已有的车中
  2. 新加一个车，放到新加的这个车里面

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 30;
  int n, m;
  int cat[N], sum[N];
  int ans = N;
  
  // 第u只猫，当前花费为k
  void dfs(int u, int k)
  {
      if (k >= ans) return;
      
      if (u == n) 
      {
          ans = k;
          return;
      }
      
      // 1.放到当前已有的一辆车里面
      for (int i = 0; i < k; i ++ )
      {
          if (cat[u] + sum[i] <= m)
          {
              sum[i] += cat[u];
              
              dfs(u + 1, k);
              
              sum[i] -= cat[u];
          }
      }
      
      // 2.新加一辆车
      sum[k] = cat[u];
      dfs(u + 1, k + 1);
      sum[k] = 0;
  }
  
  int main()
  {
      cin >> n >> m;
      for (int i = 0; i < n; i ++ ) cin >> cat[i];
      
      // 优先考虑大的，决策的方案少
      // sort(cat, cat + n, [](int x, int y) -> int {
      //     x > y;
      // });
      sort(cat, cat + n);
      reverse(cat, cat + n);
      
      dfs(0, 0);
      
      cout << ans << endl;
      
      return 0;
  }
  ```

### 木棒

+ 剪枝
  1. 按从小到大的顺序枚举木棒
  2. 木棒内部编号递增
  3. 跳过所有相等木棒
  4. 如果放第一个木棒失败了，则必定失败
  5. 如果放最后一个木棒失败了，则必定失败

### 数独

+ 顺序
  1. 每次随意挑选空的格子
  2. 枚举每个可以挑选的数字
  3. dfs

### 加成序列

+ 如果已经确定了最终的结果所在的位置是比较浅的位置，那么就应该使用迭代加深。虽然非常浅的位置会被重复搜索很多遍，但是相比起搜索到较深的地方所耗费的时间，重复搜索较浅的位置所花费的时间基本上可以忽略不记。
+ 这里 `while (!dfs(1, k)) k ++ ;` 。通过 `k` 来限制迭代的层数。这样不会一路走到死花费过多的时间在非常深的地方。

### 送礼物（双向dfs）

+ 除了迭代加深之外，双向dfs也可以很大程度上避免在深层子树上浪费时间。在一些题目中，问题不仅具有“初态”，而且还具有明确的“终态”。并且从初态到终态搜索产生的搜索树能够覆盖整个状态空间。在这种情况下， 就可以使用双向搜索。从初态和终态出发各搜索一半状态，产生两颗深度减半的搜索树，在中间交汇，组合成最终的答案。
+ 做法
  1. 将所有物品按重量从大到小排序
  2. 先将前 $K$ 件物品能凑出的所有重量打表。然后排序并判重。
  3. 搜索剩下的 $N-K$ 件物品的选择方式，然后在表中二分出不超过 $W$ 的最大值。
+ 这里首先对于前一半进行打表，打出一个前一半的所有可能结果的表。然后再在后一半中进行元素的选择。这样预处理前一半的时间复杂度是 $O(2^{23})$ ，而在之后再进行二叉查找找到前一半的中最合适的组合的时间复杂度是 $O(log_{2^{23}})$ 。这样合起来的时间复杂度是 $O(2^{23}log_2{23})$ ，可以通过。这里运用了双向dfs和用时间换空间的想法。
+ `int ct = unique(a, a + n) - a` 这里把a（已经排好序了的一个容器）进行去重，并且得出 `ct` 是这个容器中去重之后剩下的元素个数。

### 排书

+ `A*` 和 `IDA*` 的区别应该是 `A*` 是普通的搜索加上 $f(n)$ 启发函数，而 `IDA*` 是迭代加深的思想，按照 $f(n)$ 启发函数来确定搜索的层数。

### dfs优化

+ 优化搜索顺序，优先搜索分支少的
+ 排除冗余信息
+ 可行性检查

## 图论

+ 所有的最小生成树，prim或kruskal，都是无向边。

#### 局域网

+ 相当于在每一个块中求一颗生成树。相当于求一个”生成森林“。
+ 这道题说要求删去的边权和最大的，也就是说求剩下的边权和最小的。因此可以求出每个联通块的最小生成树，求出的这个最小生成树组成的森林就是最后生下来的图。

#### 繁忙的都市

## 高级数据结构

### 树状数组

+ 树状数组和线段树都可以用来求前缀和

+ 其主要操作如下

1. 快速求前缀和 $O(logn)$
2. 修改一个数 $O(logn)$ 

![image-20210520211310606](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master//image-20210520211310606.png)

+ 在树状数组中数组中每一个元素都代表 $[R-lowbit(R)+1,R]$ 这一段的元素的总和。
+ ![image-20201004235331837](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master//image-20201004235331837.png)

#### 楼兰图腾

+ 这道题很容易想到其朴素做法。从左往右扫一遍，每次扫到一个数字的时候将其左边以及右边再扫一遍，统计出其两边能和他组成 `V` 或者倒V的数字的个数，然后通过乘法原理乘起来。这样做的时间复杂度是 $O(n^2)$ 。但是我们很容易想到如果第一次扫的时候把左边大于他的数用树状数组记录下来，然后扫到这个元素的时候直接求出小于其的元素的个数之和，然后右边也是这样扫一遍，就能优化到 $0(nlogn)$ 的时间复杂度。因为扫一遍的时间复杂度是 $O(n)$ ，而在树状数组中求区间和的时间复杂度是 $O(logn)$ 。

+ 这里还要注意在更新 `res` 的时候要先转换为 `long long` 然后再加。因为如果不这样的话会先乘了再转换为 `long long` 。在乘的时候可能就会爆 `int` 。比如说返回的两个数都是 $10^9$ ，这时候如果先乘再转换为 `long long` 就绝对会溢出。

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  typedef long long ll;
  
  #define lowbit(x) ((x) & (-(x)))
  const int N = 200010;
  
  int a[N], tr[N];
  int gt[N], lower[N];
  int n;
  
  void add(int x, int v)
  {
      for (int i = x; i <= n; i += lowbit(i)) tr[i] += v;
  }
  
  int sum(int x)
  {
      int res = 0;
      for (int i = x; i; i -= lowbit(i)) res += tr[i];
      return res;
  }
  
  int main()
  {
      cin >> n;
      for (int i = 1; i <= n; i ++ ) cin >> a[i];
      
      for (int i = 1; i <= n; i ++ )
      {
          int y = a[i];
          gt[i] = sum(n) - sum(y);
          lower[i] = sum(y - 1);
          add(y, 1);
      }
      
      memset(tr, 0, sizeof tr);
      ll res1 = 0, res2 = 0;
      for (int i = n; i > 0; i -- )
      {
          int y = a[i];
          res1 += ((ll)gt[i] * ((ll)sum(n) - (ll)sum(y)));
          res2 += (lower[i] * (ll)sum(y - 1));
          add(y, 1);
      }
      
      cout << res1 << " " << res2; 
      
      return 0;
  }
  ```

#### 一个简单的整数问题

+ 这道题说要多次给一段数字都加上一个数。把数列中 $l\sim{r}$ 的元素每个都加上 $d$ 。很容易想到这里可以用到差分的方法。而在求某一个数的值的时候，需要将差分数组的 $1\sim n$ 的数全都加起来。如果用普通的差分数组的话这个操作的事件复杂度是 $O(n)$ 。因此很容易想到要用树状数组将时间复杂度优化为 $O(logn)$ 。在初始化整个树状数组的时候的时间复杂度是 $O(n)$ ，操作的事件复杂度是 $0(logn)$ ，总时间复杂度是 $max(O(n), O(mlogn))$ 。

  ```cpp
  #include <iostream>
  
  const int N = 100010;
  
  using namespace std;
  
  int tr[N], a[N];
  int n, m;
  
  int lowbit(int x)
  {
      return x & -x;
  }
  
  void add(int x, int v)
  {
      for (int i = x; i <= n; i += lowbit(i)) tr[i] += v;
  }
  
  int sum(int x)
  {
      int res = 0;
      for (int i = x; i; i -= lowbit(i)) res += tr[i];
      
      return res;
  }
  
  int main()
  {
      cin >> n >> m;
      for (int i = 1; i <= n; i ++ ) cin >> a[i];
      
      for (int i = 1; i <= n; i ++ ) add(i, a[i] - a[i - 1]);
  
      while (m -- )
      {
          char op[2];
          cin >> op;
          if (*op == 'Q')
          {
              int t;
              cin >> t;
              cout << sum(t) << endl;
          }
          else
          {
              int l, r, d;
              cin >> l >> r >> d;
              add(l, d), add(r + 1, -d);
          }
      }
      
      return 0;
  }
  ```

#### 一个简单的整数问题2

+ 维护区间的时候和上一题的思想类似，也是用树状数组维护一个差分数组。但是在需要区间和的时候则和上一题的思想不太相同。在上一题中，想要求出 $a[x]$ ，只需要求出差分数组中的 $\sum_{i=1}^{x}{b[i]}$ 。但是在这一题中，如果想要求出 $\sum_{i=l}^{r}a[i]$ 则需要求出 $\sum_{i=l}^{r}\sum_{j=1}^{i}b[j]$ 。需要进行两层循环。如果只是暴力按照之前的做法来做的话时间复杂度 $O(nmlogn)$ 是一定会超时的。

+ ![image-20210521113308033](https://cdn.jsdelivr.net/gh/smallzhong/new-picgo-pic-bed@master//image-20210521113308033.png)

+ $\sum_{i=l}^{r}\sum_{j=1}^{i}b[j]$ 可以看成
  $$
  \begin{equation}       %开始数学环境
  \left(                 %左括号
    \begin{array}{ccc}  
      b1\\  %第一行元素
      b1 & b2 \\  %第二行元素
      b1 & b2 & b3\\
      b1 & b2 & b3 & b4\\
      ...
    \end{array}
  \right)                 %右括号
  \end{equation}
  $$
  这样一个矩阵。比如 $a[1]\sim{a[4]}$ 的区间和的矩阵如上图所示。但是这个矩阵不容易用代码求出来，，因此可以将其进行如下的填充
  $$
  \begin{equation}       %开始数学环境
  \left(                 %左括号
    \begin{array}{ccc}   %该矩阵一共3列，每一列都居中放置
      b1 & \textcolor{red}{b2} & \textcolor{red}{b3} & \textcolor{red}{b4} \\  %第一行元素
      b1 & b2 & \textcolor{red}{b3} & \textcolor{red}{b4} \\  %第二行元素
      b1 & b2 & b3 & \textcolor{red}{b4} \\
      b1 & b2 & b3 & b4\\
      ...
    \end{array}
  \right)                 %右括号
  \end{equation}
  $$
  这一个矩阵中每个元素的和就很好求得了。在求得总和之后再减去标红的元素的总和，就可以求得真正的 $a[l]\sim{a[r]}$ 的和。其公式如下

  $\sum_{i=l}^{r}\sum_{j=1}^{i}b[j]=\sum_{i=1}^{x}(x-i+1)\times{b[i]}=(x+1)\sum_{i=1}^x{b[i]}-\sum_{i=1}^{x}i\times{b[i]}$  

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  typedef long long ll;
  typedef long long LL;
  
  const int N = 100010;
  
  int n, m;
  ll tr1[N], tr2[N]; // tr1是b[i]的前缀和，tr2是b[i] * i的前缀和
  ll a[N];
  
  int lowbit(int x)
  {
      return x & -x;
  }
  
  void add(ll tr[], int x, ll v)
  {
      for (int i = x; i <= n; i += lowbit(i)) tr[i] += v;
  }
  
  ll sum(ll tr[], int x)
  {
      ll res = 0;
      for (int i = x; i; i -= lowbit(i)) res += tr[i];
      return res;
  }
  
  ll prefix_sum(int x)
  {
      return sum(tr1, x) * (x + 1) - sum(tr2, x);
  }
  
  int main()
  {
      cin >> n >> m;
      for (int i = 1; i <= n; i ++ ) cin >> a[i];
      
      for (int i = 1; i <= n; i ++ )
      {
          ll b = a[i] - a[i - 1];
          add(tr1, i, b);
          add(tr2, i, (ll)b * i);
      }
      
      while (m -- )
      {
          char op[2];
          cin >> op;
          int l, r, d;
          cin >> l >> r;
          if (*op == 'Q')
          {
              cout << prefix_sum(r) - prefix_sum(l - 1) << endl;
          }
          else
          {
              cin >> d;
              add(tr1, l, d), add(tr2, l, l * d);
              add(tr1, r + 1, -d), add(tr2, r + 1, (r + 1) * -d);
          }
      }
      
      return 0;
  }
  ```

#### 谜一样的牛

+ 在这一题中，最后一头牛前面有 $k$ 头比它高的牛就说明它是高度 $k+1$ 的牛。比如最后一头牛前面有2头比它高的牛，则说明其是第3高的牛。

+ 这道题可以从后往前遍历，把每一个身高如果被选中了设置为0，未被选中设置为1，这样我们可以通过求编号所对应的 **前缀和** 来确定这个编号前面还有几头比其还高的牛。而这个前缀和数组可以使用 **树状数组** 来优化为 $0(logn)$ 的时间复杂度，这样可以避免 $O(n^2)$ 时间复杂度导致超时的问题。

+ 在查找当前身高为 $k$ 的牛的身高应该为多少的时候可以用二分结合树状数组来做。

  ```cpp
  #include <iostream>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 1E5 + 10;
  int tr[N], a[N], ans[N];
  int n;
  
  int lowbit(int x)
  {
      return x & -x;
  }
  
  void add(int x, int v)
  {
      for (int i = x; i <= n; i += lowbit(i)) tr[i] += v;
  }
  
  int sum(int x)
  {
      int res = 0;
      for (int i = x; i; i -= lowbit(i)) res += tr[i];
      
      return res;
  }
  
  int main()
  {
      cin >> n;
      for (int i = 2; i <= n; i ++ ) cin >> a[i];
      for (int i = 1; i <= n; i ++ ) add(i, 1);
      
      for (int i = n; i; i -- )
      {
          int k = a[i] + 1;
          int l = 1, r = n;
          
          while (l < r)
          {
              int mid = l + r >> 1;
              if (k <= sum(mid)) r = mid;
              else l = mid + 1;
          }
  
          ans[i] = l;
          add(l, -1);
      }
      
      for (int i = 1; i <= n; i ++ ) cout << ans[i] << endl;
      
      return 0;
  }
  ```

### 线段树

+ 线段树在开空间的时候要开 `4 * n` 的空间。
+ 在划分的时候我们把一个区间 $[l,r]$ 划分为 $[l,mid]$ 和 $[mid+1,r]$ 。
+ 为什么 `pushup` 的时候不用一直递归更新到顶层呢，只更新一层是否会导致上面的数据不正确？ 

#### 你能回答这些问题吗

+ 