### 试除法判断质数

+ 试除法的时间复杂度 `O(sqrt(n))` 。（一定根号n，并不是说最坏根号n）。

不要写 `i * i <= n` 这样容易溢出。推荐写法是 `i <= n / i`



## 试除法分解质因数

+ 最坏 `O(sqrt(n))` 但是一般没那么慢。

+ 这里会枚举所有的数而不是所有的质数，但并不会影响结果。因为当我们枚举到 `i` 的时候说明 `x` 中已经不包含任何小于等于 `i` 的因子了。所以最终的结果不会有问题。

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <algorithm>
  
  using namespace std;
  
  void divide(int x)
  {
      for (int i = 2; i <= x / i; i ++ )
      {
          if (x % i == 0) // 只要这个成立，i一定是质数。
          {
              int s = 0;
              while (x % i == 0)
              {
                  s ++ ;
                  x /= i;
              }
              cout << i << " " << s << endl;
          }
      }
      if (x > 1) cout << x << " 1" << endl;
      puts("");
  }
  
  int main()
  {
      int n;
      cin >> n;
      while (n -- )
      {
          int t;
          cin >> t;
          divide(t);
      }
      
      return 0;
  }
  ```

  

### 筛质数

+ ![image-20201111175606292](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201111175606292.png)

  当一个数不是质数的时候就不需要筛掉其所有的倍数，只需要筛掉 `p` 的质数次方的那些数字就可以了。

+ 朴素筛法时间复杂度是 `O(nlogn)` （logn以e为底）

+ 优化后的筛法（埃筛）时间复杂度

  ![image-20201111175856764](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201111175856764.png)

  跟 `O(n)` 是一个数量级的。

+ ![image-20201111182717297](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201111182717297.png)

+ 埃筛代码如下

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 1000010;
  
  int primes[N], cnt;
  bool st[N];
  
  void get_primes(int n)
  {
      for (int i = 2; i <= n; i ++ )
      {
          if (st[i]) continue; // 如果是合数（已经被筛过了），跳过
          // 否则说明这个数是质数，开始用这个数筛
          else
          {
              primes[cnt ++ ] = i;
              // 只有当这个数是质数的时候才用这个数筛，放在else里面
              for (int j = i + i; j <= n; j += i)
                  st[j] = true;
          }
      }
  }
  
  int main()
  {
      int n;
      cin >> n;
      
      get_primes(n);
      
      cout << cnt << endl;
      
      return 0;
  }
  ```

+ 线性筛法代码如下

+ 其原理是保证了每个合数都是被其 **最小质因子** 筛掉的。

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 1000010;
  
  int primes[N], cnt;
  bool st[N];
  
  void get_primes(int n)
  {
      for (int i = 2; i <= n; i ++ )
      {
          if (!st[i]) primes[cnt ++ ] = i;
          // 循环的判断条件不用加上j < cnt，因为如果这个数是质数的话一定会在primes[j] = i的时候停下来（因为已经加进去了），而如果是合数的话会在其最小质因子处停下来（因为其最小质因子一定小于其本身）。
          for (int j = 0; primes[j] <= n / i; j ++ )
          {
              st[primes[j] * i] = true;
              if (i % primes[j] == 0) break; // 找到了最小质因子primes[j]
          }
      }
  }
  
  int main()
  {
      int n;
      cin >> n;
  
      get_primes(n);
  
      cout << cnt << endl;
  
      return 0;
  }
  ```




### 试除法求约数

+ 时间复杂度是 `O(sqrt(n))` 。

  ```cpp
  #include <iostream>
  #include <algorithm>
  #include <vector>
  
  using namespace std;
  
  vector<int> get_divisor(int x)
  {
      vector<int> res;
      for (int i = 1; i <= x / i; i ++ )
      {
          if (x % i == 0)
          {
              res.push_back(i);
              // 防止 i * i == x 的时候被推进去两次
              if (i != x / i) res.push_back(x / i);
          }
      }
      sort(res.begin(), res.end());
      return res;
  }
  
  int main()
  {
      int T;
      cin >> T;
      while (T -- )
      {
          int x;
          cin >> x;
          auto res = get_divisor(x);
          for (auto a : res) cout << a << " ";
          puts("");
      }
      
      return 0;
  }
  ```



### 约数个数 && 约数之和

+ 在 `INT_MAX` 范围内约数个数最多大概在 **1500** 左右。

+ ![image-20201111211220652](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201111211220652.png)

+ 先对于每一个数分解质因数，得到 `a1` 、`a2` 等等，然后套 `(a1 + 1) * (a2 + 1) * (a3 + 1) ...` 的公式。

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <map>
  #include <unordered_map>
  
  using namespace std;
  
  const int mod = 1e9 + 7;
  typedef long long ll;
  
  int main()
  {
      // 存放a1、a2 ...
      unordered_map<int, int> primes;
      int T;
      cin >> T;
      while (T -- )
      {
          int x;
          cin >> x;
          // 试除法分解因数
          for (int i = 2; i <= x / i; i ++ )
          {
              while (x % i == 0)
              {
                  x /= i;
                  primes[i] ++ ;
              }
          }
          
          if (x > 1) primes[x] ++ ;
      }
      
      ll res = 1;
      for (auto prime : primes) res = res * (prime.second + 1) % mod;
      
      cout << res << endl;
      
      return 0;
  }
  ```

+ 约数之和（这里 `t * p + 1` ）不太理解

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <map>
  #include <unordered_map>
  
  using namespace std;
  
  const int mod = 1e9 + 7;
  typedef long long ll;
  
  int main()
  {
      // 存放a1、a2 ...
      unordered_map<int, int> primes;
      int T;
      cin >> T;
      while (T -- )
      {
          int x;
          cin >> x;
          // 试除法分解因数
          for (int i = 2; i <= x / i; i ++ )
          {
              while (x % i == 0)
              {
                  x /= i;
                  primes[i] ++ ;
              }
          }
          
          if (x > 1) primes[x] ++ ;
      }
      
      ll res = 1;
  
      for (auto prime : primes)
      {
          int p = prime.first, a = prime.second;
          ll t = 1;
          while (a -- ) t = (t * p + 1) % mod;
          res = res * t % mod;
      }
      
      cout << res << endl;
      
      return 0;
  }
  ```

  

