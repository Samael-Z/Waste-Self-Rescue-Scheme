### 双链表

```cpp
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <string>

using namespace std;

const int N = 100010;
int e[N], l[N], r[N], idx;

void insert(int k, int x)
{
    e[idx] = x;
    r[idx] = r[k];
    l[idx] = k;
    l[r[k]] = idx;
    r[k] = idx ++ ;
}

void remove(int k)
{
    r[l[k]] = r[k];
    l[r[k]] = l[k];
}

int main()
{
    r[0] = 1, l[1] = 0;
    idx = 2;
    
    int T;
    cin >> T;
    
    while (T -- )
    {
        string op;
        int x;
        cin >> op >> x;
        if (op == "L") insert(0, x);
        else if (op == "R") insert(l[1], x);
        else if (op == "D") remove(x + 1);
        else if (op == "IL")
        {
            int t;
            cin >> t;
            insert(l[x + 1], t);
        }
        else if (op == "IR")
        {
            int t;
            cin >> t;
            insert(x + 1, t);
        }
    }

    for (int i = r[0]; i != 1; i = r[i])
    {
        printf("%d ", e[i]);
    }
    
    return 0;
}
```

### KMP字符串

+ `next[i] = j` 的含义是模式字符串中 `p[1, j]` 和 `p[i - j + 1, i]` 是相等的。也就是 **第一个字符到第j的字符** 组成的字符串和 **第i - j + 1到第i的字符是相等的** 。

  ![image-20201029190320145](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201029190320145.png)

+ `next` 在某个头文件里面有，所以起名为 `ne` 才能万无一失。 

+ 代码如下

  ```cpp
  #include <iostream>
  
  using namespace std;
  
  const int N = 100010, M = 1000010;
  
  char p[N], s[M];
  int n, m;
  int ne[N];
  
  int main()
  {
     cin >> n >> p + 1 >> m >> s + 1;
     
     for (int i = 2, j = 0; i <= n; i ++ )
     {
         while (j && p[j + 1] != p[i]) j = ne[j];
         if (p[j + 1] == p[i]) j ++ ;
         ne[i] = j;
     }
     
     for (int i = 1, j = 0; i <= m; i ++ )
     {
         while (j && p[j + 1] != s[i]) j = ne[j];
         if (p[j + 1] == s[i]) j ++ ;
         if (j == n)
         {
             // 匹配成功
             printf("%d ", i - n); // 减去模式字符串的长度等于起点
             j = ne[j];
         }
     }
     
     return 0;
  }
  ```

  

### TRIE树

+ 因为一个字符串的末尾是 `\0` ，所以可以这样遍历字符串

  ```cpp
  for (int i = 0; str[i]; i ++ )
  ```

+ 代码如下

  ```cpp
  #include <iostream>
  #include <stdio.h>
  
  using namespace std;
  
  const int N = 100010;
  
  char str[N];
  int cnt[N];
  int son[N][26 + 1], idx;
  
  void insert()
  {
      int p = 0;
      for (int i = 0; str[i]; i ++ )
      {
          int u = str[i] - 'a';
          if (!son[p][u]) son[p][u] = ++ idx;
          p = son[p][u];
      }
      cnt[p] ++ ;
  }
  
  int query()
  {
      int p = 0;
      for (int i = 0; str[i]; i ++ )
      {
          int u = str[i] - 'a';
          if (!son[p][u]) son[p][u] = ++ idx;
          p = son[p][u];
      }
      return cnt[p];
  }
  
  int main()
  {
      int T;
      cin >> T;
      while (T -- )
      {
          char op[2];
          cin >> op >> str;
          if (*op == 'I') insert();
          else cout << query() << endl;
      }
      
      return 0;
  }
  ```

  