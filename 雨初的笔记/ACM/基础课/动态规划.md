# 背包

+ 用 `w` 来表示价值是因为 `w` 一般用来表示权重。



### 01背包

+  `f(i, j)` 表示只从前 `i` 个物品中选，总体积小于 `j` 的最大值。

+ 状态计算就是将当前的整个集合划分成若干个更小的子集，使得每个集合都能被算出来。

+ ![image-20201113201707302](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201113201707302.png)

  + 不选择 `i` 的集合与从 `1~i-1` 中选取的值是一样的，即 `f(i - 1, j)` 

  + 而对于选择 `i` 的集合，曲线救国，先求出 `f(i - 1, j - v[i])` ，即从 `1~i-1` 中选，且总体积减去一个 `v[i]` 。则 `f(i - 1, j - v[i]) + w[i]` 即为我们要求的值。

    > 要注意这里如果 `j < v[i]` 的话说明背包里面装不下第 `i` 件物品，所以这个集合是空集。

  + 综上 `f(i - 1, j) = max(f(i - 1, j), f(i - 1, j - v[i]) + w[i])` 。

+ 朴素做法代码如下

  ```cpp
  #include <string.h>
  #include <iostream>
  #include <stdio.h>
  
  using namespace std;
  
  const int N = 1010;
  
  int n, m;
  int v[N], w[N];
  int f[N][N];
  
  int main()
  {
      cin >> n >> m;
      for (int i = 1; i <= n; i ++ ) cin >> v[i] >> w[i];
      
      for (int i = 1; i <= n; i ++ )
          for (int j = 1; j <= m; j ++ )
          {
              f[i][j] = f[i - 1][j];
              if (j >= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
          }
          
      cout << f[n][m] << endl;
      
      return 0;
  }
  ```

+ 滚动数组优化

+ 把第一维优化没了，但是因为如果写成 `for (int j = v[i]; j <= m; j ++ )` 的话每一次比较的时候相当于 `f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i])` 。因为 `j - v[i]` 严格小于 `j` ，所以每次判断的时候 `f[j - v[i]]` 其实已经被计算过了，是这一层的 `f[i][j - v[i]] + w[i]` 而不是本应是的上一层的 `f[i - 1][j - v[i]] + w[i]` 。所以结果是错误的。

  ```cpp
  #include <string.h>
  #include <iostream>
  #include <stdio.h>
  
  using namespace std;
  
  const int N = 1010;
  
  int n, m;
  int v[N], w[N];
  int f[N];
  
  int main()
  {
      cin >> n >> m;
      for (int i = 1; i <= n; i ++ ) cin >> v[i] >> w[i];
      
      for (int i = 1; i <= n; i ++ )
          for (int j = m; j >= v[i]; j -- )
              f[j] = max(f[j], f[j - v[i]] + w[i]);
              
      cout << f[m];
  
      return 0;
  }
  ```

  

### 完全背包

![image-20201113211922923](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201113211922923.png)

完全背包优化可优化为只枚举两个状态，就不用枚举 `k` 个状态了。

![image-20201115095553331](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201115095553331.png)

+ 无优化版

```cpp
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>

using namespace std;

const int N = 1010;

int f[N][N], w[N], v[N];

int main()
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ ) cin >> v[i] >> w[i];
    
    for (int i = 1; i <= n; i ++ )
        for (int j = 0; j <= m; j ++ )
            for (int k = 0; k * v[i] <= j; k ++ )
            {
                f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]);
            }
            
    cout << f[n][m];
    
    return 0;
}
```

+ 通过推导将 `k` 优化掉

![image-20201115095553331](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201115095553331.png)

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;
int f[N][N], w[N], v[N];

int main()
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ ) cin >> v[i] >> w[i];
    
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
        {
            f[i][j] = f[i - 1][j];
            if (j >= v[i]) f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]);
        }
        
    cout << f[n][m];
    
    return 0;
}
```

+ 滚动数组优化掉第一维度
+ 因为这里状态转移方程是 `f[i][j] = max(f[i - 1][j], f[i][j - v[i]] + w[i])` ，用的是 `f[i][]` 的值，所以不用怕滚动的时候把前面的值覆盖了导致错误，因为我们想要得到的就是前面的值，所以不用像01背包那样从后往前循环。

```cpp
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>

using namespace std;

const int N = 1010;

int f[N], w[N], v[N];

int main()
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i ++ ) cin >> v[i] >> w[i];
    
    for (int i = 1; i <= n; i ++ )
        for (int j = v[i]; j <= m; j ++ )
            f[j] = max(f[j], f[j - v[i]] + w[i]);
            
    cout << f[m];
    
    return 0;
}
```



### 多重背包

+ 朴素版的多重背包问题和朴素版完全背包差不多，改一下判断条件就可以。

  ```cpp
  #include <iostream>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 110;
  int f[N][N], w[N], v[N], s[N];
  
  int main()
  {
      int n, m;
      cin >> n >> m;
      for (int i = 1; i <= n; i ++ ) cin >> v[i] >> w[i] >> s[i];
      
      for (int i = 1; i <= n; i ++ )
          for (int j = 1; j <= m; j ++ )
              for (int k = 0; v[i] * k <= j && k <= s[i]; k ++ )
              {
                  f[i][j] = max(f[i][j], f[i - 1][j - v[i] * k] + k * w[i]);
              }
              
      cout << f[n][m];
      
      return 0;
  }
  ```

  

### 二进制优化多重背包

+ 把一个元素分解为 `logs` 个元素，然后当作 **01背包** 问题来解决这个问题。