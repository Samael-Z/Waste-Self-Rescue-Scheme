## （一）

### 八皇后

+ 这道题先按照最原始的思路来想吧，第二种方法的斜对角线和反斜对角线的判断有点不太理解。

+ 判断是否在同一对角或者反对角线的方法就是 **看截距** 。比如经过点 `(1, 1)` 的对角线和反对角线的截距都是 `1 + 1 == 2` ，则 `dg[x + y] = udg[x + y] = true` 即可。即 `dg[2] = udg[2] = true` 。这里dg是 *diagonal* （对角线）的意思。

+ 当然这里 `(0, 9)` 和 `(9, 0)` 会标记在同一个斜对角线和反斜对角线上，但是事实上他们并不在同一个斜对角线而只在同一个反斜对角线上。不过既然他们在同一反斜对角线上，这种条件必然不可以选，所以这样写也是没问题的。

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <stdlib.h>
  
  using namespace std;
  
  const int N = 20;
  bool col[N], row[N], dg[N * N], udg[N * N];
  int n;
  char g[N][N];
  
  void dfs(int x, int y, int s)
  {
      if (s > n) return;
      if (y == n) x ++ , y = 0;
      if (x == n)
      {
          if (s == n)
          {
              for (int i = 0; i < n; i ++ ) puts(g[i]);
              puts("");
          }
          return;
      }
      
      g[x][y] = '.';
      dfs(x, y + 1, s); // 不要这一个点
      
      if (!col[y] && !row[x] && !dg[x + y] && !udg[x - y + n]) // 如果可以要这个点
      {
          col[y] = row[x] = dg[x + y] = udg[x - y + n] = true;
          g[x][y] = 'Q';
          dfs(x, y + 1, s + 1);
          g[x][y] = '.';
          col[y] = row[x] = dg[x + y] = udg[x - y + n] = false;
      }
      
  }
  
  int main()
  {
      cin >> n;
      for (int i = 0; i < n; i ++ )
          for (int j = 0; j < n; j ++ )
              g[i][j] = '.';
      dfs(0, 0, 0);
      return 0;
  }
  ```

  

## 图

+ 在图论题里面计算时间复杂度的时候一般把 **点的个数** 记作 `n` ，把 **边的条数** 记作 `m` 。

+ 树是一种特殊的图（无环联通图），无向图也是一种特殊的有向图。

+ Y总的邻接表是用 **链表** 来实现的，和算法笔记里面用 `vector<int>` 来存稍有不同。（Y总说是因为 `vector` 的速度比数组模拟要慢一些。 ）

+ 链表添加的模板

  ![image-20201024184027629](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201024184027629.png)

+ 树和图深度优先搜索的模板

  ![image-20201024184233414](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201024184233414.png)
  
+ 树和图的DFS和BFS的时间复杂度都跟 **点数和边数** 成线性关系 `0(n + m)` 。因为每个点都只会被遍历到一次。



### 树的重心

+ 这道题 `int dfs(int u)` 返回的是这个从这个节点往下走有多少个节点

  ```cpp
  #include <algorithm>
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  
  using namespace std;
  
  const int N = 100010, M = N * 2; // 边的条数可能比节点个数多
  int h[N], e[M], ne[M], n, idx;
  int ans = N;
  bool st[M];
  
  void add(int a, int b)
  {
      e[idx] = b, ne[idx] = h[a], h[a] = idx;
      idx ++ ;
  }
  
  // 返回的是u这个点往下DFS有多少个节点
  int dfs(int u)
  {
      st[u] = true;
      
      int sum = 1, res = 0; // sum用来返回dfs的结果（这个点往下有多少个点(包括这个点本身)），res用来存储这个点子块的最大值
      for (int i = h[u]; i != -1; i = ne[i])
      {
          int j = e[i];
          if (st[j]) continue;
          
          int s = dfs(j); // 从这个点往下有多少个点
          res = max(res, s);
          sum += s; // 累加结果
      }
      res = max(res, n - sum); // 上面的子块
      ans = min(res, ans);
      return sum;
  }
  
  int main()
  {
      cin >> n;
      memset(h, -1, sizeof h);
      for (int i = 0; i < n; i ++ )
      {
          int a, b;
          cin >> a >> b;
          add(a, b), add(b, a);
      }
      dfs(1);
      cout << ans << endl;
      return 0;
  }
  ```

### 图中点的层次

+ 图的bfs，和普通bfs没有很大区别

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <algorithm>
  #include <string.h>
  #include <queue>
  
  using namespace std;
  
  const int N = 100010, M = N * 2;
  int e[N], ne[N], h[N], idx;
  int d[N];
  int n, m;
  
  void add(int a, int b)
  {
      e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
  }
  
  int bfs()
  {
      memset(d, -1, sizeof d);
      queue<int> q;
      q.push(1);
      d[1] = 0;
      while (q.size())
      {
          int t = q.front();
          q.pop();
          for (int i = h[t]; i != -1; i = ne[i])
          {
              int j = e[i];
              if (d[j] == -1)
              {
                  d[j] = d[t] + 1;
                  q.push(j);
              }
          }
      }
      return d[n];
  }
  
  int main()
  {
      memset(h, -1, sizeof h);
      cin >> n >> m;
      for (int i = 0; i < m; i ++ )
      {
          int a, b;
          cin >> a >> b;
          add(a, b);
      }
      cout << bfs();
      return 0;
  }
  ```

  

### 有向图的拓扑序列

+ 只有有向图有拓扑序列，无向图没有拓扑序列。

+ 如果有环则不能构成拓扑序列。（因为没有顺序）

+ 可以证明，一个有向无环图一定存在拓扑序列。所以有向无环图也被称为拓扑图。

+ 有多少条边指向自己就是一个点的入度，有多少条边出去就是一个点的出度。

+ 所有入度为0的点都可以作为起点。（因为不会有任何一个点会在前面）

+ 一个有向无环图**至少存在一个入度为0的点。**

+ 这道题首先遍历所有入度为0的点（这里有点问题，如果输入是这样的那输出是正确的吗）

  ![image-20201024211439611](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201024211439611.png)

  并将其入队，然后进行BFS，每BFS到一个点就删除这条边。这样如果BFS结束后所有的点都进入过队列，那么说明这组数据可以得到拓扑序列，合法。

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <algorithm>
  #include <string.h>
  
  using namespace std;
  
  const int N = 100010, M = N * 2;
  int n, m;
  int e[N], ne[N], h[N], idx;
  int q[N];
  int d[N]; // 记录每个点的入度
  
  void add(int a, int b)
  {
      e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
  }
  
  bool topsort()
  {
      int hh = 0, tt = -1;
      for (int i = 1; i <= n; i ++ )
          if (d[i] == 0) // 遍历所有
              q[ ++ tt] = i;
  
      while (hh <= tt)
      {
          int t = q[hh ++ ];
          for (int i = h[t]; i != -1; i = ne[i])
          {
              int j = e[i];
              d[j] -- ;
              if (d[j] == 0)
                  q[ ++ tt] = j;
          }
      }
      return (tt == n - 1); // 如果所有元素都入过队，那么说明无环。
  }
  
  int main()
  {
      memset(h, -1, sizeof h);
      cin >> n >> m;
      for (int i = 0; i < m; i ++ )
      {
          int a, b;
          cin >> a >> b;
          add(a, b);
          d[b] ++ ;
      }
      
      if (topsort())
      {
          for (int i = 0; i < n; i ++ ) printf("%d ", q[i]);
          cout << endl;
      }
      else
          puts("-1");
      
      return 0;
  }
  ```



## （二）

![image-20201024223356104](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201024223356104.png)

+ 最短路的难度在于建图，将题目抽象出图。

### dijkstra

+ 在图论题里面计算时间复杂度的时候一般把 **点的个数** 记作 `n` ，把 **边的条数** 记作 `m` 。

+ 朴素版 `dijkstra` 算法的时间复杂度是 `0(n ^ 2)` ，堆优化版的 `dijkstra` 算法的时间复杂度是 `0(mlogn)` 。所以对于稠密图一般使用朴素版 `dijkstra` ，对于稀疏图一般使用对优化版 `dijkstra` 。

+ ![image-20201024233354749](C:\Users\雨初\AppData\Roaming\Typora\typora-user-images\image-20201024233354749.png)

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 510;
  int g[N][N], dist[N];
  bool st[N];
  int n, m;
  
  int dijkstra()
  {
      memset(dist, 0x3f, sizeof dist);
      dist[1] = 0; // 1到1的距离为0
      for (int i = 0; i < n - 1; i ++ ) // 迭代n次
      {
          int t = -1; // t是当前能到达的最近的点
          // 遍历所有的点，找出当前能到达的最近的点
          for (int j = 1; j <= n; j ++ )
          {
              // 如果这个点没有走过或者这个点比之前的距离要短，则更新为这个点
              if (!st[j] && (t == -1 || dist[t] > dist[j]))
                  t = j;
          }
          for (int j = 1; j <= n; j ++ )
          {
              // 如果从t这个点到这个点比较近，那么更新其最短距离
              dist[j] = min(dist[j], dist[t] + g[t][j]);
          }
          
          // 把t标记为已访问
          st[t] = true;
      }
      
      if (dist[n] == 0x3f3f3f3f) return -1;
      return dist[n];
  }
  
  int main()
  {
      memset(g, 0x3f, sizeof g);
      cin >> n >> m;
      while (m -- )
      {
          int x, y, z;
          cin >> x >> y >> z;
          g[x][y] = min(g[x][y], z); // 保留最短的边
      }
      
      cout << dijkstra();
      return 0;
  }
  ```

  