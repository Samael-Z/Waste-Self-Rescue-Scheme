## （一）

### 八皇后

+ 这道题先按照最原始的思路来想吧，第二种方法的斜对角线和反斜对角线的判断有点不太理解。

+ 判断是否在同一对角或者反对角线的方法就是 **看截距** 。比如经过点 `(1, 1)` 的对角线和反对角线的截距都是 `1 + 1 == 2` ，则 `dg[x + y] = udg[x + y] = true` 即可。即 `dg[2] = udg[2] = true` 。这里dg是 *diagonal* （对角线）的意思。

+ 当然这里 `(0, 9)` 和 `(9, 0)` 会标记在同一个斜对角线和反斜对角线上，但是事实上他们并不在同一个斜对角线而只在同一个反斜对角线上。不过既然他们在同一反斜对角线上，这种条件必然不可以选，所以这样写也是没问题的。

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <stdlib.h>
  
  using namespace std;
  
  const int N = 20;
  bool col[N], row[N], dg[N * N], udg[N * N];
  int n;
  char g[N][N];
  
  void dfs(int x, int y, int s)
  {
      if (s > n) return;
      if (y == n) x ++ , y = 0;
      if (x == n)
      {
          if (s == n)
          {
              for (int i = 0; i < n; i ++ ) puts(g[i]);
              puts("");
          }
          return;
      }
      
      g[x][y] = '.';
      dfs(x, y + 1, s); // 不要这一个点
      
      if (!col[y] && !row[x] && !dg[x + y] && !udg[x - y + n]) // 如果可以要这个点
      {
          col[y] = row[x] = dg[x + y] = udg[x - y + n] = true;
          g[x][y] = 'Q';
          dfs(x, y + 1, s + 1);
          g[x][y] = '.';
          col[y] = row[x] = dg[x + y] = udg[x - y + n] = false;
      }
      
  }
  
  int main()
  {
      cin >> n;
      for (int i = 0; i < n; i ++ )
          for (int j = 0; j < n; j ++ )
              g[i][j] = '.';
      dfs(0, 0, 0);
      return 0;
  }
  ```

  

## 图

+ 在图论题里面计算时间复杂度的时候一般把 **点的个数** 记作 `n` ，把 **边的条数** 记作 `m` 。

+ 树是一种特殊的图（无环联通图），无向图也是一种特殊的有向图。

+ Y总的邻接表是用 **链表** 来实现的，和算法笔记里面用 `vector<int>` 来存稍有不同。（Y总说是因为 `vector` 的速度比数组模拟要慢一些。 ）

+ 链表添加的模板

  ![image-20201024184027629](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201024184027629.png)

+ 树和图深度优先搜索的模板

  ![image-20201024184233414](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201024184233414.png)
  
+ 树和图的DFS和BFS的时间复杂度都跟 **点数和边数** 成线性关系 `0(n + m)` 。因为每个点都只会被遍历到一次。



### 树的重心

+ 这道题 `int dfs(int u)` 返回的是这个从这个节点往下走有多少个节点

  ```cpp
  #include <algorithm>
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  
  using namespace std;
  
  const int N = 100010, M = N * 2; // 边的条数可能比节点个数多
  int h[N], e[M], ne[M], n, idx;
  int ans = N;
  bool st[M];
  
  void add(int a, int b)
  {
      e[idx] = b, ne[idx] = h[a], h[a] = idx;
      idx ++ ;
  }
  
  // 返回的是u这个点往下DFS有多少个节点
  int dfs(int u)
  {
      st[u] = true;
      
      int sum = 1, res = 0; // sum用来返回dfs的结果（这个点往下有多少个点(包括这个点本身)），res用来存储这个点子块的最大值
      for (int i = h[u]; i != -1; i = ne[i])
      {
          int j = e[i];
          if (st[j]) continue;
          
          int s = dfs(j); // 从这个点往下有多少个点
          res = max(res, s);
          sum += s; // 累加结果
      }
      res = max(res, n - sum); // 上面的子块
      ans = min(res, ans);
      return sum;
  }
  
  int main()
  {
      cin >> n;
      memset(h, -1, sizeof h);
      for (int i = 0; i < n; i ++ )
      {
          int a, b;
          cin >> a >> b;
          add(a, b), add(b, a);
      }
      dfs(1);
      cout << ans << endl;
      return 0;
  }
  ```

### 图中点的层次

+ 图的bfs，和普通bfs没有很大区别

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <algorithm>
  #include <string.h>
  #include <queue>
  
  using namespace std;
  
  const int N = 100010, M = N * 2;
  int e[N], ne[N], h[N], idx;
  int d[N];
  int n, m;
  
  void add(int a, int b)
  {
      e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
  }
  
  int bfs()
  {
      memset(d, -1, sizeof d);
      queue<int> q;
      q.push(1);
      d[1] = 0;
      while (q.size())
      {
          int t = q.front();
          q.pop();
          for (int i = h[t]; i != -1; i = ne[i])
          {
              int j = e[i];
              if (d[j] == -1)
              {
                  d[j] = d[t] + 1;
                  q.push(j);
              }
          }
      }
      return d[n];
  }
  
  int main()
  {
      memset(h, -1, sizeof h);
      cin >> n >> m;
      for (int i = 0; i < m; i ++ )
      {
          int a, b;
          cin >> a >> b;
          add(a, b);
      }
      cout << bfs();
      return 0;
  }
  ```

  

### 有向图的拓扑序列

+ 只有有向图有拓扑序列，无向图没有拓扑序列。

+ 如果有环则不能构成拓扑序列。（因为没有顺序）

+ 可以证明，一个有向无环图一定存在拓扑序列。所以有向无环图也被称为拓扑图。

+ 有多少条边指向自己就是一个点的入度，有多少条边出去就是一个点的出度。

+ 所有入度为0的点都可以作为起点。（因为不会有任何一个点会在前面）

+ 一个有向无环图**至少存在一个入度为0的点。**

+ 这道题首先遍历所有入度为0的点（这里有点问题，如果输入是这样的那输出是正确的吗）

  ![image-20201024211439611](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201024211439611.png)

  并将其入队，然后进行BFS，每BFS到一个点就删除这条边。这样如果BFS结束后所有的点都进入过队列，那么说明这组数据可以得到拓扑序列，合法。

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <algorithm>
  #include <string.h>
  
  using namespace std;
  
  const int N = 100010, M = N * 2;
  int n, m;
  int e[N], ne[N], h[N], idx;
  int q[N];
  int d[N]; // 记录每个点的入度
  
  void add(int a, int b)
  {
      e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
  }
  
  bool topsort()
  {
      int hh = 0, tt = -1;
      for (int i = 1; i <= n; i ++ )
          if (d[i] == 0) // 遍历所有
              q[ ++ tt] = i;
  
      while (hh <= tt)
      {
          int t = q[hh ++ ];
          for (int i = h[t]; i != -1; i = ne[i])
          {
              int j = e[i];
              d[j] -- ;
              if (d[j] == 0)
                  q[ ++ tt] = j;
          }
      }
      return (tt == n - 1); // 如果所有元素都入过队，那么说明无环。
  }
  
  int main()
  {
      memset(h, -1, sizeof h);
      cin >> n >> m;
      for (int i = 0; i < m; i ++ )
      {
          int a, b;
          cin >> a >> b;
          add(a, b);
          d[b] ++ ;
      }
      
      if (topsort())
      {
          for (int i = 0; i < n; i ++ ) printf("%d ", q[i]);
          cout << endl;
      }
      else
          puts("-1");
      
      return 0;
  }
  ```



## （二）

![image-20201024223356104](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201024223356104.png)

+ 最短路的难度在于建图，将题目抽象出图。

### dijkstra

+ **`dijkstra`一定不能存在负权边**

+ 在图论题里面计算时间复杂度的时候一般把 **点的个数** 记作 `n` ，把 **边的条数** 记作 `m` 。

+ 朴素版 `dijkstra` 算法的时间复杂度是 `0(n ^ 2)` ，堆优化版的 `dijkstra` 算法的时间复杂度是 `0(mlogn)` 。所以对于稠密图一般使用朴素版 `dijkstra` ，对于稀疏图一般使用对优化版 `dijkstra` 。

+ ![image-20201024233354749](C:\Users\雨初\AppData\Roaming\Typora\typora-user-images\image-20201024233354749.png)

+ 朴素 `dijkstra` 这道题是一个稠密图，所以可以用邻接矩阵来做。

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 510;
  int g[N][N], dist[N];
  bool st[N];
  int n, m;
  
  int dijkstra()
  {
      memset(dist, 0x3f, sizeof dist);
      dist[1] = 0; // 1到1的距离为0
      for (int i = 0; i < n - 1; i ++ ) // 迭代n次
      {
          int t = -1; // t是当前能到达的最近的点
          // 遍历所有的点，找出当前能到达的最近的点
          // 这里有两重遍历，是朴素版dijkstra算法中最慢的部分。主要是为了找到离当前点距离最短的点。
          for (int j = 1; j <= n; j ++ )
          {
              // 如果这个点没有走过或者这个点比之前的距离要短，则更新为这个点
              if (!st[j] && (t == -1 || dist[t] > dist[j]))
                  t = j;
          }
          for (int j = 1; j <= n; j ++ )
          {
              // 如果从t这个点到这个点比较近，那么更新其最短距离
              dist[j] = min(dist[j], dist[t] + g[t][j]);
          }
          
          // 把t标记为已访问
          st[t] = true;
      }
      
      if (dist[n] == 0x3f3f3f3f) return -1;
      return dist[n];
  }
  
  int main()
  {
      memset(g, 0x3f, sizeof g);
      cin >> n >> m;
      while (m -- )
      {
          int x, y, z;
          cin >> x >> y >> z;
          g[x][y] = min(g[x][y], z); // 保留最短的边
      }
      
      cout << dijkstra();
      return 0;
  }
```
  
+ 堆优化版的 `dijkstra`

  https://www.acwing.com/solution/content/6291/

  朴素 `dijkstra` 最慢的地方**就在找到当前能走到的距离最近的点(O(n ^ 2))**。而堆优化版的 `dijkstra` 用堆优化了这里。

+ 朴素版 `dijkstra` 算法的时间复杂度是 `0(n ^ 2)` ，堆优化版的 `dijkstra` 算法的时间复杂度是 `0(mlogn)` 。

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  #include <map>
  #include <queue>
  
  using namespace std;
  typedef pair<int, int> pii;
  #define xx first
  #define yy second
  
  const int N = 1000010;
  
  bool st[N];
  int e[N], ne[N], w[N], h[N], idx;
  int n, m;
  int dist[N];
  
  void add(int a, int b, int c)
  {
      e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++ ;
  }
  
  int dijkstra()
  {
      memset(dist, 0x3f, sizeof dist);
      dist[1] = 0;
      
      priority_queue<pii, vector<pii>, greater<pii>> heap;
      heap.push(make_pair(0, 1));
      
      while (heap.size())
      {
          pii t = heap.top();
          heap.pop();
          
          int ver = t.yy, distance = t.xx;
          
          // printf("ver = %d, distance = %d\n", ver, distance);
         
          if (st[ver]) continue; // 如果这个已经走到过了，说明存储的是冗余的数据
          st[ver] = true;
          
          // 更新最短路
          for (int i = h[ver]; i != -1; i = ne[i])
          {
              // 得到这条边指向哪里
              int j = e[i];
              if (dist[j] > dist[ver] + w[i])
              {
                  // 如果从ver走向j的距离比直接到j的距离短，更新距离。
                  dist[j] = dist[ver] + w[i]; // 这里注意是w[i]，因为w的下标是idx。
                  // printf("dist[%d] = dist[%d] + w[%d] = %d = %d + %d\n", j, ver, i, dist[j], dist[ver], w[i]);
                  heap.push(make_pair(dist[j], j));
              }
          }
      }
      if (dist[n] == 0x3f3f3f3f) return -1;
      return dist[n];
  }
  
  int main()
  {
      memset(h, -1, sizeof h);
      
      cin >> n >> m;
  
      while (m -- )
      {
          int a, b, c;
          cin >> a >> b >> c;
          add(a, b, c);
      }
  
      cout << dijkstra();
      return 0;
  }
  ```

  

### bellman-ford

+ 如果能求出最短路，那么这个图里面不能有负权回路。不然只要不断循环走这个回路，路径的长度就能无限减少。

+ 如果用 `SPFA` 则要求图中不存在负环。

+ 如果规定了**走的边数的个数**，那么不能用 `SPFA` ，只能用 `bellman-ford` 。而且如果规定了走的边数的个数，那么就算图中有负环也没关系了。（实际问题中比如说要求飞机的航线，但是换乘次数不能过多，即规定了走的边数的个数。）

+ 因为 `bellman-ford` 算法要遍历到每一条边，所以不需要用邻接表或者邻接矩阵来存储，直接用一个结构体就可以。

  ```cpp
  struct
  {
      int a, b, c;
  } edges[N];
  ```

+ 为了防止更新距离的时候出现串联的情况，要开一个 `int backup[N]` 数据，每一次更新数据的时候通过 `backup` 数据中存储的上一次的距离来更新。这样就不会出现串联的问题。（第三章 搜索与图论（二）1：25：00）

+ 判断能否到达的时候不能像 `dijkstra` 那样通过 

  ```cpp
  if (dist[n] == 0x3f3f3f3f) return -1;	
  ```

  来更新。因为有可能负权边会把正无穷给更新了![image-20201025103101486](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201025103101486.png)

  这样的话就不是严格等于正无穷了。所以对于 `bellman-ford` 算法，要使用

  ```cpp
  if (dist[n] > 0x3f3f3f3f / 2) return -1;
  ```

  判断是否能到达。

+ 如果有负环其更新的形式会是怎么样的还是不太理解。应该是题目限制了只能走k条边，所以算法里面是

  ```cpp
  for (int i = 0; i < k; i ++ )
  ```

+ 题目代码如下

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  
  using namespace std;
  
  const int N = 510, M = 10010;
  int n, m, k;
  int dist[N];
  int backup[N];
  
  struct
  {
      int a, b, w;
  } edges[M];
  
  void bellman_ford()
  {
      memset(dist, 0x3f, sizeof dist);
      
      // 初始化距离
      dist[1] = 0;
      
      // 一共只能走k条边。
      for (int i = 0; i < k; i ++ )
      {
          memcpy(backup, dist, sizeof dist);
          for (int j = 0; j < m; j ++ )
          {
              int a = edges[j].a, b = edges[j].b, w = edges[j].w;
              // 松弛操作，更新最短路径，如果从a到b比b当前的距离要短，则更新b的最短路径
              // 这里不能是min(backup[b], backup[a] + w)，因为这个for循环会一直更新dist，如果使用backup就会出现问题。
              dist[b] = min(dist[b], backup[a] + w);
          }
      }
  }
  
  int main()
  {
      cin >> n >> m >> k;
      for (int i = 0; i < m; i ++ )
      {
          int a, b, w;
          cin >> a >> b >> w;
          edges[i] = {a, b, w};
      }
      
      bellman_ford();
      
      if (dist[n] > 0x3f3f3f3f / 2) printf("impossible");
      else printf("%d\n", dist[n]);
      return 0;
  }
  ```

+ 一般的最短路问题中都不会有负环。

## SPFA

+ `SPFA` 是对 `bellman-ford` 算法的优化，思想是只要有节点变小了，那么我们就把它放到队列里面去。这样就不用遍历全部了。也就是

  ```cpp
  if (dist[b] > backup[a] + w)
  ```

  那么就将这个节点放到队列里面。当然如果当前队列里面已经有了这个元素，即 `st[i] == true` 那么它就一定会被更新到，就不用再入队。而如果这个元素出队了，即已经更新了一遍其他元素的最短路径，那么就将 `st[i] = false` ，让之后他可以重新入队。

+ 代码如下

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <algorithm>
  #include <string.h>
  #include <queue>
  
  using namespace std;
  
  const int N = 100010;
  int e[N], w[N], ne[N], h[N], idx;
  int n, m;
  bool st[N];
  int dist[N];
  
  void add(int a, int b, int c)
  {
      e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++ ;
  }
  
  int spfa()
  {
      memset(dist, 0x3f, sizeof dist);
      dist[1] = 0;
      
      queue<int> q;
      q.push(1);
      st[1] = true;
      
      while (q.size())
      {
          int t = q.front();
          q.pop();
          
          st[t] = false;
          
          for (int i = h[t]; i != -1; i = ne[i])
          {
              int j = e[i];
              if (dist[j] > dist[t] + w[i])
              {
                  dist[j] = dist[t] + w[i];
                  if (st[j] == false)
                  {
                      q.push(j);
                      st[j] = true;
                  }
              }
          }
      }
  
      return dist[n];
  }
  
  int main()
  {
      memset(h, -1, sizeof h);
      
      scanf("%d%d", &n, &m);
      
      while (m -- )
      {
          int a, b, c;
          scanf("%d%d%d", &a, &b, &c);
          add(a, b, c);
      }
      
     int t = spfa();
     
     if (t == 0x3f3f3f3f) puts("impossible");
     else cout << t;
      
      return 0;
  }
  ```

  + 笔试题交 `SPFA` 一般都没事，一般数据比较水。

### SPFA判负环

+ ![image-20201025171237415](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201025171237415.png)

  每次更新距离的时候同时也更新从1到这个点经过的边数 `cnt[x]` 。而如果 `cnt[x] >= n` ，则说明其至少经过了 `n + 1` 个点才到达这个点。说明路径中出现了环。

+ 代码如下

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  #include <queue>
  
  using namespace std;
  
  const int N = 10010;
  
  int n, m;
  int dist[N];
  bool st[N];
  int cnt[N];
  int e[N], ne[N], w[N], idx, h[N];
  
  void add(int a, int b, int c)
  {
      e[idx] = b, ne[idx] = h[a], w[idx] = c, h[a] = idx ++ ;
  }
  
  bool spfa()
  {
      queue<int> q;
      
      for (int i = 1; i <= n; i ++ )
      {
          st[i] = true;
          q.push(i);
      }
      
      while (q.size())
      {
          int t = q.front();
          q.pop();
          
          st[t] = false;
          
          for (int i = h[t]; i != -1; i = ne[i])
          {
              int j = e[i];
              if (dist[j] > dist[t] + w[i])
              {
                  dist[j] = dist[t] + w[i];
                  cnt[j] = cnt[t] + 1;
                  
                  if (st[j] == false)
                  {
                      q.push(j);
                      st[j] = true;
                  }
                  if (cnt[j] >= n) return true;
              }
          }
      }
      
      return false;
  }
  
  int main()
  {
      memset(h, -1, sizeof h);
      cin >> n >> m;
      while (m -- )
      {
          int a, b, c;
          cin >> a >> b >> c;
          add(a, b, c);
      }
      if (spfa()) puts("Yes");
      else puts("No");
      return 0;
  }
  ```



### floyd算法

+ `floyd` 算法可以处理负权边，但是也是不能处理 **负权回路** 的。

+ `floyd` 算法复杂度 `O(n ^ 3)` ，三重循环。

+ 三重循环中通过

  ```cpp
  g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
  ```

  不断更新最短路径。将从 `i` 到 `j` 的最短路径更新为从 `i` 到 `k` 然后再从 `k` 到 `j` 两者中的最短路径。

+ 出现 `runtime error` 可以通过删代码的方法来判断问题出现在哪里。

+ `floyd` 算法也存在和 `bellman-ford` 算法一样的问题，不能用

  ```cpp
  if (d[a][b] == INF)
  ```

  来判断不通，因为有可能其距离会被负权边更新。所以要用

  ```cpp
  if (d[a][b] > INF / 2)
  ```

  来替代。

+ 代码如下

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <algorithm>
  #include <string.h>
  
  using namespace std;
  
  const int N = 220, INF = 1E9;
  int g[N][N];
  int n, m, T;
  
  void floyd()
  {
      for (int k = 1; k <= n; k ++ )
          for (int i = 1; i <= n; i ++ )
              for (int j = 1; j <= n; j ++ )
              {
                  // 判断从i到j的距离跟先从i到k然后从k到j的距离哪个比较短
                  g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
              }
  }
  
  int main()
  {
      cin >> n >> m >> T;
      for (int i = 1; i <= n; i ++ )
          for (int j = 1; j <= n; j ++ )
              if (i == j) g[i][j] = 0; // 自己到自己的距离是0
              else g[i][j] = INF;
      
      while (m -- )
      {
          int x, y, z;
          cin >> x >> y >> z;
          g[x][y] = min(g[x][y], z);
      }
      
      floyd();
      
      while (T -- )
      {
          int x, y;
          cin >> x >> y;
          if (g[x][y] > INF / 2) puts("impossible");
          else cout << g[x][y] << endl;
      }
      
      return 0;
  }
  ```

  