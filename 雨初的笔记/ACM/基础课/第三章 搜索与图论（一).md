## dfs

### 八皇后

+ 这道题先按照最原始的思路来想吧，第二种方法的斜对角线和反斜对角线的判断有点不太理解。

+ 判断是否在同一对角或者反对角线的方法就是 **看截距** 。比如经过点 `(1, 1)` 的对角线和反对角线的截距都是 `1 + 1 == 2` ，则 `dg[x + y] = udg[x + y] = true` 即可。即 `dg[2] = udg[2] = true` 。这里dg是 *diagonal* （对角线）的意思。

+ 当然这里 `(0, 9)` 和 `(9, 0)` 会标记在同一个斜对角线和反斜对角线上，但是事实上他们并不在同一个斜对角线而只在同一个反斜对角线上。不过既然他们在同一反斜对角线上，这种条件必然不可以选，所以这样写也是没问题的。

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <stdlib.h>
  
  using namespace std;
  
  const int N = 20;
  bool col[N], row[N], dg[N * N], udg[N * N];
  int n;
  char g[N][N];
  
  void dfs(int x, int y, int s)
  {
      if (s > n) return;
      if (y == n) x ++ , y = 0;
      if (x == n)
      {
          if (s == n)
          {
              for (int i = 0; i < n; i ++ ) puts(g[i]);
              puts("");
          }
          return;
      }
      
      g[x][y] = '.';
      dfs(x, y + 1, s); // 不要这一个点
      
      if (!col[y] && !row[x] && !dg[x + y] && !udg[x - y + n]) // 如果可以要这个点
      {
          col[y] = row[x] = dg[x + y] = udg[x - y + n] = true;
          g[x][y] = 'Q';
          dfs(x, y + 1, s + 1);
          g[x][y] = '.';
          col[y] = row[x] = dg[x + y] = udg[x - y + n] = false;
      }
      
  }
  
  int main()
  {
      cin >> n;
      for (int i = 0; i < n; i ++ )
          for (int j = 0; j < n; j ++ )
              g[i][j] = '.';
      dfs(0, 0, 0);
      return 0;
  }
  ```

  

## 图

+ 树是一种特殊的图（无环联通图），无向图也是一种特殊的有向图。

+ Y总的邻接表是用 **链表** 来实现的，和算法笔记里面用 `vector<int>` 来存稍有不同。（Y总说是因为 `vector` 的速度比数组模拟要慢一些。 ）

+ 链表添加的模板

  ![image-20201024184027629](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201024184027629.png)

+ 树和图深度优先搜索的模板

  ![image-20201024184233414](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201024184233414.png)
  
+ 树和图的DFS和BFS的时间复杂度都跟 **点数和边数** 成线性关系 `0(n + m)` 。因为每个点都只会被遍历到一次。



### 树的重心

