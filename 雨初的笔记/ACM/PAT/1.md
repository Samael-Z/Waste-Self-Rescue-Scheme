### 并查集

#### 战争中的城市

+ 这道题每一次都遍历所有边，用和那个特定点无关的边初始化并查集，然后遍历一遍得出有多少个集合。

### 树

### 中序遍历加后序遍历求层序遍历

+ 如果要构造二叉树，必须有 **中序遍历** 。比如中序遍历和前序遍历，中序遍历和后序遍历。层序遍历不知道可不可行。

+ 因为有一个操作是需要在中序遍历里面找到某一个元素的位置，因此我们这里可以使用一个哈希表（unordered_map）来存储相应的下标。

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <queue>
  #include <algorithm>
  #include <unordered_map>
  
  using namespace std;
  
  const int N = 35;
  
  int n;
  unordered_map<int, int> pos;
  int inorder[N], postorder[N];
  int l[N], r[N];
  bool flag;
  
  int build(int il, int ir, int pl, int pr)
  {
      int root = postorder[pr];
      int k = pos[root]; // 找到root在中序遍历中的位置
      if (k != il) l[root] = build(il, k - 1, pl, pl + (k - 1 - il)); // 这里的(k - 1 - il)是因为后序遍历和中序遍历的长度肯定是一样的。中序遍历的长度是(k - 1 - il)，因此后序遍历的pr是pl + (k - 1 - il)
      if (k != ir) r[root] = build(k + 1, ir, pl + (k - 1 - il) + 1, pr - 1);
      
      return root;
  }
  
  void bfs(int root)
  {
      queue<int> q;
      q.push(root);
      
      while (q.size())
      {
          int t = q.front();
          q.pop();
          if (!flag)
          {
              flag = true;
              printf("%d", t);
          }
          else printf(" %d", t);
          if (l[t]) q.push(l[t]);
          if (r[t]) q.push(r[t]);
      }
  }
  
  int main()
  {
      cin >> n;
      for (int i = 0; i < n; i ++ ) cin >> postorder[i];
      for (int i = 0; i < n; i ++ )
      {
          cin >> inorder[i];
          pos[inorder[i]] = i;
      }
      
      int root = build(0, n - 1, 0, n - 1);
      
      bfs(root);
      
      return 0;
  }
  ```

### 最深的根

+ 这道题首先要通过并查集确定有多少个联通块。

+ 在建树的时候，因为方向不固定，所以要用无向边来建树。因此在dfs求树的深度的时候要多传一个 `father` 变量进去以确定其父亲，如果发现 `j == father` 的时候就跳过，防止循环遍历。

  ```cpp
  #include <iostream>
  #include <stdio.h>
  #include <string.h>
  #include <algorithm>
  #include <vector>
  
  using namespace std;
  
  const int N = 10010, M = N * 2;
  
  int n;
  int p[N];
  int e[M], ne[M], h[N], idx;
  
  int find(int x)
  {
      if (x != p[x]) p[x] = find(p[x]);
      return p[x];
  }
  
  void add(int a, int b)
  {
      e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
  }
  
  int dfs(int u, int father)
  {
      int depth = 0;
      for (int i = h[u]; ~i; i = ne[i])
      {
          int j = e[i];
          if (j == father) continue;
          depth = max(depth, dfs(j, u) + 1);
      }
      
      return depth;
  }
  
  int main()
  {
      memset(h, -1, sizeof h);
      for (int i = 0; i < N; i ++ ) p[i] = i;
      
      cin >> n;
      int cnt = n;
      for (int i = 0; i < n; i ++ )
      {
          int a, b;
          cin >> a >> b;
          
          int pa = find(a), pb = find(b);
          if (pa != pb)
          {
              cnt -- ;
              p[pa] = pb;
          }
          add(a, b), add(b, a);
      }
      
      if (cnt > 1) printf("Error: %d components\n", cnt);
      else
      {
          vector<int> nodes;
          int max_depth = 0;
          for (int i = 1; i <= n; i ++ )
          {
              // 第二个参数是其父亲。因为是双向边，防止回头
              int depth = dfs(i, -1);
              if (depth > max_depth)
              {
                  max_depth = depth;
                  nodes.clear();
                  nodes.push_back(i);
              }
              else if (depth == max_depth)
                  nodes.push_back(i);
          }
          
          for (auto i : nodes) printf("%d\n", i);
      }
      
      return 0;
  }
  ```

  