## 数据结构

### Splay

#### splay

+ splay除了可以处理平衡树可以处理的问题，还可以处理很多类似线段树处理的问题，跟线段有关的，比如翻转一段区间。

+ `splay` 保持平衡的方式和普通的平衡树有一定的区别。每次进行 **插入** 或者 **查询** 的操作的时候，会将插入或者查询的数变到树根，同时保持树的中序遍历不变。

+ 每操作一个节点，均将该节点旋转到树根。

+ 可以证明，按照 `splay` 的旋转方式，其平均每次操作的时间复杂度是 $O(logn)$ 。

+ `splay(x, k)` 这个函数的作用是将 `x` 这个点旋转到 `k` 点的下面。

+ 为了将 `x` 转到根节点，有两种情况

  ![image-20210917231309719](https://raw.githubusercontent.com/smallzhong/new-picgo-pic-bed/main/image-20210917231309719.png)

  一种是一条的，一种是折线的。每一种都有一种对称的形状。对于第一种一长条的，使用先转 `y` 再转 `x` 的方法。对于第二种情况使用转两次 `x` 的方法。这一点背过即可。一定要这样转才是 `splay` 。如果不这样转的话不一定能达到 $O(logn)$ 的时间复杂度。

+ `splay(x, k)` 是 `splay` 的核心函数，其他所有操作都是围绕这个操作来进行的。

+ 如果想要在某个特定的点 `y` 后面插入一个序列的话

  1. 找到 `y` 的后继 `z` 。（其中序遍历的后继）

  2. 将 ``转到根 `splay(y, 0)`

  3. 

##  分块

#### 一个简单的整数问题2

+ 其实分块的思想也是一种优雅的暴力。

+ 这道题里面，把区间分成大小为 $sqrt(n)$ 的段。在需要对每一段进行操作的时候对其懒标记进行操作。如果操作的区间是段内的一小段，那么可以选择直接暴力来做。

+ 因为段的数量是 $sqrt(n)$  ，而段内的元素的数量也是 $sqrt(n)$ ，因此这样的做法每一次查询的时间复杂度是 $sqrt(n)$ 。

  ```cpp
  #include <bits/stdc++.h>
  
  using namespace std;
  
  typedef long long ll;
  
  const int N = 1e5 + 10;
  
  // sum是包括add后的值的。
  ll sum[N], add[N];
  int w[N];
  int n, m, len;
  
  int get(int i)
  {
      // 为什么第一块长度为len-1不影响结果？
      // 应该是因为虽然长度为len，但是在加的时候不可能整段加
      // 在这一段里面每次加的时候都必然是一个个暴力加
      // 所以第一段少一个元素并不影响结果
      return (i - 1) / len;
  }
  
  void change(int l, int r, int d)
  {
      // 如果两个在同一个段内，直接暴力
      if (get(l) == get(r))
      {
          for (int i = l; i <= r; i ++ ) 
          {
              w[i] += d;
              sum[get(i)] += d;
          }
      }
      else
      {
          // 首先跳过首尾所在的段，时间复杂度为O(sqrt(n)
          int i = l, j = r;
          while (get(i) == get(l))
          {
              w[i] += d;
              sum[get(i)] += d;
              i ++ ;
          }
          
          while (get(j) == get(r))
          {
              w[j] += d;
              sum[get(j)] += d;
              j -- ;
          }
          
          for (int k = get(i); k <= get(j); k ++ ) 
          {
              sum[k] += d * len;
              add[k] += d;
          }
      }
  }
  
  ll query(int l, int r)
  {
      ll res = 0;
      
      // 如果两个是在同一个段内
      if (get(l) == get(r)) 
      {
          for (int i = l; i <= r; i ++ ) res += w[i] + add[get(i)];
          return res;
      }
      else
      {
          int i = l, j = r;
          
          while (get(i) == get(l)) 
          {
              res += w[i] + add[get(i)];
              i ++ ;
          }
          
          while (get(j) == get(r))
          {
              res += w[j] + add[get(j)];
              j -- ;
          }
          
          for (int k = get(i); k <= get(j); k ++ ) 
          {
              res += sum[k];
          }
          
          return res;
      }
  }
  
  signed main()
  {
      scanf("%d%d", &n, &m);
      len = sqrt(n);
      
      for (int i = 1; i <= n; i ++ ) 
      {
          scanf("%d", &w[i]);
          sum[get(i)] += w[i];
      }
      
      char op[2];
      int l, r, d;
      
      while (m -- ) 
      {
          scanf("%s%d%d", op, &l, &r);
          
          if (*op == 'C')
          {
              scanf("%d", &d);
              change(l, r, d);
          }
          else printf("%lld\n", query(l, r));
      }
      
      return 0;
  }
  ```

  

## 莫队算法

+ 莫队算法其实就是一种经过优化的暴力。
+ http://fangkaipeng.com/?p=1504

#### HH的项链

+ 