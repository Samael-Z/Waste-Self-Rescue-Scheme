+ 32位程序中的内存区域分配如下

  ![image-20210307095147840](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210307095147840.png)

  所谓不能访问应该就是没有挂物理页，但是如果想使用，手动挂上物理页，应该可行

  >这里到时候试一下在x64里面不能进入的内存挂一个物理页看能不能访问

+ 在内核中，使用一个链表把所有的内存串起来。在用户空间中，使用的是一个二叉搜索树（应该就是那个VAD结构），对于系统内存（内核里面的内存）的管理机制，可以查《windows内核原理与实现》第四章。

  ![image-20210307095850831](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210307095850831.png)

  

+ `EPROCESS + 11C` 的位置是 `VadRoot` ，这里面存储着一个二叉搜索树，每一个点都指示了一块占用的地址空间。每一个节点的类型是 `_MMVAD`

  ![image-20210307100721635](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210307100721635.png)

  `StartingVpn` 和 `EndingVpn` 是最重要的两个成员。其都是以页（4kb）为单位的，在后面加上3个零就是线性地址开始和结束的位置。比如这张图中这个结构指示的内存地址就从 `7c800000` 开始，到 `7c91c000` 结束。

  + `+0x18` 的这个 `_CONTROL_AREA` 结构体如下

    ![image-20210307102204884](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210307102204884.png)

    如果 `+0x24` 这个 `FilePointer` 指针为空，说明上面这个 `MMVAD` 结构体指示的地址是真正的物理页。而如果 `FilePoint` 非空，这个指针有值，指向一个 `FILE_OBJECT` 对象

    ![image-20210307102411770](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210307102411770.png)

    说明当前线性地址指向的内存不是我们自己分的，而是映射过来的，是map内存。

    > 所有内存中只有两类内存，①使用VirtualAlloc分配的普通内存②使用Map映射的内存（文件映射）

+ 如果想知道哪里的线性地址没有被占用，我们需要遍历这颗二叉树，才能发现哪些内存空间是没有被使用过的。

+ 