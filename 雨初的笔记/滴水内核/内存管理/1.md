+ 32位程序中的内存区域分配如下

  ![image-20210307095147840](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210307095147840.png)

  所谓不能访问应该就是没有挂物理页，但是如果想使用，手动挂上物理页，应该可行

  >这里到时候试一下在x64里面不能进入的内存挂一个物理页看能不能访问

+ 在内核中，使用一个链表把所有的内存串起来。在用户空间中，使用的是一个二叉搜索树（应该就是那个VAD结构），对于系统内存（内核里面的内存）的管理机制，可以查《windows内核原理与实现》第四章。

  ![image-20210307095850831](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210307095850831.png)

  

+ `EPROCESS + 11C` 的位置是 `VadRoot` ，这里面存储着一个二叉搜索树，每一个点都指示了一块占用的地址空间。每一个节点的类型是 `_MMVAD`

  ![image-20210307100721635](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210307100721635.png)

  `StartingVpn` 和 `EndingVpn` 是最重要的两个成员。其都是以页（4kb）为单位的，在后面加上3个零就是线性地址开始和结束的位置。比如这张图中这个结构指示的内存地址就从 `7c800000` 开始，到 `7c91c000` 结束。

  + `+0x18` 的这个 `_CONTROL_AREA` 结构体如下

    ![image-20210307102204884](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210307102204884.png)

    如果 `+0x24` 这个 `FilePointer` 指针为空，说明上面这个 `MMVAD` 结构体指示的地址是真正的物理页。而如果 `FilePoint` 非空，这个指针有值，指向一个 `FILE_OBJECT` 对象

    ![image-20210307102411770](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210307102411770.png)

    说明当前线性地址指向的内存不是我们自己分的，而是映射过来的，是map内存。其 `+0x30` 位置指示了其映射的是那个文件。

    > 所有内存中只有两类内存，①使用VirtualAlloc分配的普通内存②使用Map映射的内存（文件映射）

  + `_MMVAD` 中的 `u` 是一个联合体

    ![image-20210307103538000](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210307103538000.png)

    一般使用的是 `MMVAD_FLAGS` 这个成员，用来标识这一块内存的属性，是写拷贝、只读还是可读可执行之类的。

    + ![image-20210307104800773](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20210307104800773.png)

      最后一个属性 `PrivateMemory` 标识当前的这块内存是 `private` 的还是映射的，如果值为 **1** ，说明当前这块内存是私有的（是我们自己申请的），如果值为 **0** ，说明当前这块内存是映射的。

+ 如果想知道哪里的线性地址没有被占用，我们需要遍历这颗二叉树，才能发现哪些内存空间是没有被使用过的。

+ `!vad` 指令可以让windbg帮我们遍历所有的节点。 `!vad 开始的根节点` 遍历以我们给的节点为根节点的二叉搜索树。

+ 模块隐藏，比如把自己的dll注了进去，也会在 `vadroot` 里面有这一块内存，可以找到。如果试图在这里面把我们注进去的dll摘掉，那么操作系统可能会认为这一块内存没有人使用，到时候可能还把其他的东西放到这里面去，那么就会导致崩溃。因此在这里面摘东西是不稳定的，我们可以通过遍历 `vadroot` 来查找模块。