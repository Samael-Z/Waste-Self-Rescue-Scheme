+ ![image-20201202195236239](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201202195236239.png)

+ 如果找不到头文件可以右键重新加载解决方案

+ virtualKD可以帮你生成配置，不用自己配置 `WINDBG` 。

+ 要用内置的 `typedef` 的变量类型，不要用 `int` ， `unsigned long` 这样的类型，因为在不同平台变量的长度可能不同

+ 驱动在内核中，也就是所有进程共享的高2G

+ 每一个模块都有一个结构体来描述当前这个模块的信息

+ 这个结构体里面的内容如下

  ```cpp
  kd> dt _DRIVER_OBJECT
  ntdll!_DRIVER_OBJECT
     +0x000 Type             : Int2B
     +0x002 Size             : Int2B
     +0x004 DeviceObject     : Ptr32 _DEVICE_OBJECT
     +0x008 Flags            : Uint4B
     +0x00c DriverStart      : Ptr32 Void
     +0x010 DriverSize       : Uint4B
     +0x014 DriverSection    : Ptr32 Void
     +0x018 DriverExtension  : Ptr32 _DRIVER_EXTENSION
     +0x01c DriverName       : _UNICODE_STRING
     +0x024 HardwareDatabase : Ptr32 _UNICODE_STRING
     +0x028 FastIoDispatch   : Ptr32 _FAST_IO_DISPATCH
     +0x02c DriverInit       : Ptr32     long 
     +0x030 DriverStartIo    : Ptr32     void 
     +0x034 DriverUnload     : Ptr32     void 
     +0x038 MajorFunction    : [28] Ptr32     long 
  ```

  其中最重要的几个成员如下

  ```
  DriverStart：驱动在内存中的基址
  DriverSize：驱动在内存中的大小
  DriverSection：内核模块链表基址（这个待会详细说）
  DriverName：驱动名
  ```

+ `IRQL` 跟CPU无关，是 `windows` 自己定义的一套中断等级。.

+ 分页处理程序的级别是2，则 `IRQL` 为 **2** 的程序只能访问非分页内存而不能访问分页内存。因为级别为2的程序无法把级别为2的程序打断。这时候缺页处理程序就没法处理缺页异常。因此 `IRQL = 2` 的程序只能使用分页内存。

+ 在XP里面 `ULONG(unsigned long)` 是4个字节大小

  ![image-20201203160724600](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201203160724600.png)

+ 驱动01

  ```cpp
  #include <ntddk.h>
  #include <ntdef.h>
  
  #pragma warning(disable:28159)
  #pragma warning(disable:28222)
  #pragma warning(disable:28209)
  
  
  // 卸载函数
  VOID DriverUnload(PDRIVER_OBJECT driver)
  {
  	DbgPrint("驱动程序停止运行了.\r\n");
  }
  
  // 入口函数，相当于main
  NTSTATUS DriverEntry(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path)
  {
  	// 设置一个卸载函数，便于退出
  	driver->DriverUnload = DriverUnload;
  
  	UCHAR gdt[6];
  	UCHAR idt[6];
  
  	__asm
  	{
  		sgdt fword ptr gdt
  		sidt fword ptr idt
  	}
  
  	ULONG gdtAddr, idtAddr;
  	USHORT gdtSize, idtSize;
  
  	gdtAddr = *(PULONG)(gdt + 2);
  	idtAddr = *(PULONG)(idt + 2);
  	gdtSize = *(PUSHORT)gdt;
  	idtSize = *(PUSHORT)idt;
  
  	DbgPrint("gdtAddr = %x, idtaddr = %x, gdtsize = %x, idtsize = %x\n", gdtAddr, idtAddr, gdtSize, idtSize);
  
  	PVOID gdtBuffer = ExAllocatePool(PagedPool, gdtSize);
  	PVOID idtBuffer = ExAllocatePool(PagedPool, idtSize);
  
  	RtlMoveMemory(gdtBuffer, (PVOID)gdtAddr, gdtSize);
  	RtlMoveMemory(idtBuffer, (PVOID)idtAddr, idtSize);
  
  	ULONG i;
  	DbgPrint("打印GDT表如下:\n");
  	for (i = 0; i < gdtSize; i += 16)
  		DbgPrint("%08x  %08x`%08x %08x`%08x\r\n", gdtAddr + i,
  			((PULONG)(gdtAddr + i))[1], ((PULONG)(gdtAddr + i))[0],
  			((PULONG)(gdtAddr + i))[3], ((PULONG)(gdtAddr + i))[2]);
  
  	DbgPrint("\n打印IDT表如下:\n");
  	for (i = 0; i < idtSize; i += 16)
  		DbgPrint("%08x  %08x`%08x %08x`%08x\r\n", idtAddr + i,
  			((PULONG)(idtAddr + i))[1], ((PULONG)(idtAddr + i))[0],
  			((PULONG)(idtAddr + i))[3], ((PULONG)(idtAddr + i))[2]);
  
  	ExFreePool(gdtBuffer);
  	ExFreePool(idtBuffer);
  
  	return STATUS_SUCCESS;
  }
  ```

+ 如果是 `wchar` 的话要用 `%ls` 来输出。

+ 我发现 `Length` 表示的其实是这个字符串的实际大小（以字节为单位）。

  ![image-20201203183930492](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201203183930492.png)

+ 在0环不需要句柄，没有句柄这个概念。句柄是用来给3环的程序找到内核对象使用的。

+ `TEB` 结构体是用来描述当前线程( `thread` )的。 `fs:[0]` 里面存的就是TEB的地址

  `TEB` 结构体 `0x30` 的位置是 `PEB` 指针， `PEB` 是进程结构体( `process` )

  ![image-20201203192137552](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201203192137552.png)

  其实 `PEB` 就是 `fs:[0x30]` 。

+ `TEB` 和 `PEB` 都是三环的地址，和零环没有关系，`PEB` 断链在三环就可以做。

+ 三环和零环的 `fs` 的含义是不一样的。

+ `_PEB_LDR_DATA` 

  ![image-20201203192549337](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201203192549337.png)

  ![image-20201203192647414](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201203192647414.png)

+ 隐藏模块就是通过 `TEB` 找到 `PEB` 然后通过 `PEB` 找到这三个链表，然后从这三个链表里面摘下来我们想要隐藏的模块的信息。这种方式对于只用三环API找模块的可以起作用，但是在零环有另外的方法可以找到我们想要找到的模块。