+ `句柄 / 4` 得到句柄索引，而句柄表里面的句柄成员每个是 **8个字节** 。因此 `句柄表基址 + (句柄 / 4) * 8` 可以找到对应句柄表中的成员。

+ 所有内核对象的开头都有一个 `_OBJECT_HEADRE` ，大小是 `0x18` ，因此从句柄表中得到对象的地址的的时候，要查看的话还得再+0x18。全局句柄表中就直接指向 `_EPROCESS` 或者 `_ETHREAD` ，就没有这个 `_OBJECT_HEADER` 的结构了。

+ 句柄表项每个占8字节，**一个页4KB，所以一个页能存储512个句柄表项**，当进程中的句柄数量超过512，句柄表就会以分级形式存储，最多三级：

  ![image-20210214155516674](https://raw.githubusercontent.com/smallzhong/picgo-pic-bed/master/image-20210214155516674.png)



### 用句柄表实现反调试

+ 为了遍历所有进程的 `_EPROCESS` ，驱动的做法：因为零环中 `fs` 指向 `KPCR` ，则通过 `KPCR + 0X124` 找到 `_ETHREAD` ，然后通过 `ETHREAD + 0x220` 找到其对应的 `EPROCESS` 。找到 `EPROCESS` 之后通过 `EPROCESS + 0X88` 的 `EPROCESS` 链表遍历所有的进程结构体。这样做的局限性是如果对方在零环进行 `EPROCESS` 断链，则这个方法就会失效。此处仅作为练习。