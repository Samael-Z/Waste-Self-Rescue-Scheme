+ https://int3.club/2020/04/18/1.%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/
+ `GS` WINDOWS没有用，一进到0环再出来 `GS` 就会被清零
+ ![image-20201120181951510](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120181951510.png)

+ ![image-20201120182247199](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120182247199.png)



### 段寄存器属性探测

+ 在 `vc6` 中证明 `attribute` 存在 

  ```cpp
  int var = 0;  //全局变量
  int main()
  {
       __asm
      {
          mov ax,ss //ss可读可写
          mov ds,ax 
          mov dword ptr ds:[var],eax
      }
  }
  ```

  ![image-20201120184019044](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120184019044.png)

  无报错

+ 而如果换成 `cs` ，因为 `cs` 是可读可执行不可写的，会报 `0xc0000005` 错误

  ![image-20201120184213561](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120184213561.png)



+ 证明 `base` 存在

  ```cpp
  int var = 0;  //全局变量
  int main()
  {
       __asm
      {
          mov ax,fs
          mov gs,ax
          mov eax,gs:[0]    //不能使用ds 否则会出错(vc6) 原因可能与编译器有关
          //相当于
          //mov eax,dword ptr ds:[0x7FFDF000]   //这个地址是可以访问的
  	 }
  }
  ```

  

  ![image-20201120184512354](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120184512354.png)

  访问0地址肯定会出错，但这里 `fs:[0]` 并不是0地址，因为其 `base` 不为0

  ![image-20201120184625673](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120184625673.png)

  ![image-20201120184655382](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120184655382.png)



+ 探索 `limit` 存在

  ```cpp
  int var = 0;  //全局变量
  int main()
  {
       __asm
      {
          mov ax,fs             
          mov gs,ax
             //mov eax,gs:[0x1000] //0x7FFDF000+0x1000  0x1000 >fs.limit=0xFFF 
          //访问的地址相当于下面的 ds.limit=0xFFFFFFFF
          mov eax,dword ptr ds:[0x7FFDF000+0x1000]
          mov dword ptr ds:[var],eax
      }
  }
  ```

  ![image-20201120184921008](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120184921008.png)



### 段描述符和段选择子

+ `gdtr` 这个寄存器是 `48` 位的，存储了2个值，gdt的**地址**和**大小**。

+ Windbg指令

  - `r gdtr` //查看gdt表的位置(0x8003F000 )

  - `r gdtl` //查看gdt表的大小(0x3FF)

  - `dd(dword)` 4字节显示地址

  - `dq(qword)` 8字节显示地址(用`连接) ==高位在前低位在后==

  - `dq 8003F000 L40` (显示40组)

  - 查看 `gdtr` 的时候不要用 `dd` 来看，要用 `dq` 

    ![image-20201120185901544](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120185901544.png)

+ `gdtr` 指向的是一张表，里面存储的是段描述符

  ![image-20201120185715072](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120185715072.png)

+ 段选择子（ `mov ds, ax` 的时候 `ax` 就相当于一个段选择子）用来指向定义该段的段描述符（gdtr指向的那张表就是段描述符）

  ![image-20201120190851056](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120190851056.png)

  + 在 `windows` 下没有用 `ldt` 表， `tl` 基本上都是 `0` 。

  比如如果段选择子是 `0x001B` 的话，其拆分出来是 `0000 0000 0001 1011` 。

  ![image-20201120191024867](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120191024867.png)

  则 `index = 3` ， `tl = 0` ， `rpl = 3` 。即**查GDT表中的第三个**，请求特权级别为 **3** 。

  ![image-20201120191224713](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120191224713.png)

  即这个段描述符。

+ 修改段描述符的方法，另没有 `lcs` 指令，因为不允许只修改 `cs` 的值，要改就必须跟 `eip` 一起改。

  ![image-20201120191516950](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120191516950.png)

+ ```cpp
  char buffer[6];  
  
  void main()
  {          
  	int x = 0x23;
  	memcpy(buffer, &x, sizeof x);
  	__asm                            
  	{       
  		//xor eax, eax
  		//mov ax, es
  		//mov dword ptr ds:[t], eax
  		les ecx,fword ptr ds:[buffer] //高2个字节给es，低四个字节给ecx    
  	}
  }
  ```

  注意这里 `RPL<=DPL` （DPL是段描述符里面的）



### P位G位

+ ![image-20201120193635514](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120193635514.png)

+ 段描述符的结构

  ```cpp
  WORD  Selector;		//16位
  WORD  Atrribute;		//16位
  DWORD Base;		//32位
  DWORD Limit;		//32位      FFFFFFFF
  ```

  ![image-20201120194448720](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120194448720.png)

  + 而 `selector` 就是段选择子。

  + 这里可以看到 `limit` 有 `0~19` 共20位，而在段描述符结构体里面显示 `limit` 应是 **32位** 的。这时就要看 `G` 位。**如果 `G` 位为0**，~~说明 `limit` 的单位是 **字节** ，~~ 那么就在 `limit` 前面补上3个0，即 `G` 位为0的时候 `limit` 最大值为 `000FFFFF` 。而 **如果 `G` 位为1** ，说明 `limit` 以 `4kb` 为单位（`4kb = 4096, 4096 - 1 = 4095 = 0xfff`） ，则在 `limit` 后面加上 `fff` （即真正的 `limit` 的大小是 `20位limit * 0x1000`）。
    + 比如如果段描述符中20位 `limit` 加起来为 `0x12345` ，那么**如果 `G` 位为0**， `limit = 000FFFFF` ，如果 **`G` 位为1** ， `limit = FFFFFFFF` 。

+ >    FS对应的段描述符比较特殊，拆分后的值与段寄存器中的值不符合，讲到操作系统（线程）的时候会解释.

+ > 课后练习：
>
  > ​     分析段选择子为0x1B、0x23对应的段描述符，并将内容填写到段寄存器结构体中.
>
  > + ![image-20201120194448720](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120194448720.png)
>
  > + `0x1b = 0001 1011` ， `index = 3` ，对应段描述符为 `00cffa00 0000ffff`
  >
  > + ![image-20201120200048421](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120200048421.png)
  >
  > + 拆分得 `0000 0000 1100 1111 1111 1010 0000 0000 0000 0000 0000 0000 1111 1111 1111 1111`
  >
  >   ![image-20201120200922765](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120200922765.png)



### s位和type域

+ 操作系统检查段描述符的时候先判断 `P` 位是否为0，然后查看 `S` 位，最后看 `type` 域（**第6位**）

  ![image-20201120202750985](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120202750985.png)

  s位为0和为1的时候 `type` 域代表的属性是完全不一样的。

  > DPL在 `windows` 在只能为 **全0** 或者 **全1** 。

+ **第五位（P + DPL + S）**为 `f` 或者为 `9` 的才有可能是代码段或者数据段（s=1），否则一定不是代码段或者数据段。

+ `type` 域 **第11位** 如果为0说明是数据段，如果为1说明是代码段。即如果段描述符 **第6位** 大于8，则一定是代码段，如果小于8，则一定是数据段（前提是第五位为9或f）。

  ![image-20201120203501439](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120203501439.png)

  + 如果是**代码段**，则第10，9，8位分别为E,W,A。
    + 如果段描述符被使用过了，被访问过了，那么**A位**会被置为1，每当处理器将该段选择符（？）放入某个段寄存器的时候，就将该位置1。

      ![image-20201120205227314](C:\Users\雨初\AppData\Roaming\Typora\typora-user-images\image-20201120205227314.png)

    + **W位为0** 的时候说明这个段不可写，为1的时候说明这个段可写。

    + **E位** 为0的时候向上拓展，为1的时候向下拓展。

    + ![image-20201120205157298](C:\Users\雨初\AppData\Roaming\Typora\typora-user-images\image-20201120205157298.png)

  + 如果是 **数据段** ，那么第10，9，8位分别为C,R,A。

    ![image-20201120205559195](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120205559195.png)

    + **A位** 和数据段的意义相同，如果被使用过则置为1。
    + **R位** 表示这个代码段是否可读
    + **C位** 在后续课程会介绍，先不用管。

  + 如果是系统段（**s=0**）

    ![image-20201120205829800](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120205829800.png)



### DB位

+ ![image-20201120210248297](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120210248297.png)

+ 数据段如果加载到ss段里面则为ss段，但其仍为数据段，这点要理解

+ ![image-20201120210814803](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120210814803.png)

  + 如果是向下拓展，而且 `D = 0` ，那么只有图中红色的一段是有效的。因为其段的上限为 `64KB` 。

  ![image-20201120210710161](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120210710161.png)



### 段属性检测

+ `windows` 没有使用1环和2环

+ `cs` 段选择子后两位存储的值称为 `CPL` ，当前进程的特权级别。如果后两位为 `11` ，则其跑在3环，如果为 `00` 则跑在0环。比如 `cs = 001b` 表示这个进程跑在3环。

+ `cs` 和 `ss` 后两位的值一定是相同的（这是X86规定的），其均表示当前进程的 `CPL(特权级别)`

+ 而段描述符中的 `DPL`

  ![image-20201120212937428](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120212937428.png)

  则规定了要访问我需要什么特权级别。

  ![image-20201120213009469](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120213009469.png)

  而 `RPL` 是针对段选择子而言的

  ![image-20201121100242365](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201121100242365.png)

+ 总结：

  + ![image-20201120212937428](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201120212937428.png)
  + ![image-20201121100623881](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201121100623881.png)

  + **CPL** ：CPU当前的权限级别（当前进程的权限级别）

  + **DPL** ：如果你想访问我，你应该具备什么样的权限（这个属性是在GDT表的段描述符里面的，即如果想要访问这个段需要什么样的权限）

  + **RPL** ：用什么权限去访问一个段（这个属性在段选择子后三位）

  + 必须 **CPL权限比DPL权限大** 且 **RPL权限比DPL权限大** 。如果当前进程 `CPL` 权限是0，但是为了避免错误也可以将访问的权限 `RPL` 设置为3。

    > 为啥要有RPL?
    >
    > ​	我们本可以用“读 写”的权限去打开一个文件，但为了避免出错，有些时候我们使用“只读”的权限去打开。（防止错误操作）

    > 这里只是针对 **数据段** 的段描述符说的，如果是**系统段或者代码段**则会有所不同。