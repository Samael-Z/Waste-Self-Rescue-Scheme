### 4-1

+ `PsGetCurrentProcess` 可以获取当前的进程的 `PEPROCESS` ，`PsGetProcessImageFileName` 可以获取当前进程的进程名， `PsGetProcessImageFileName(PsGetCurrentProcess());` 这样使用。

+ 非分页内存表示其不会被存到硬盘上，永远不会离开内存，不会出现缺页。

+ ```cpp
  #pragma code_seg("PAGE")
  ```

  可以指定这一块内存为分页内存。如果不写或者括号中为空则默认为非分页内存。

+ `ExAllocatePoolWithTag` 申请的内存可以用 `ExFreePoolWithTag` 来释放。

### 4-2

+ ![image-20210515151405744](C:\Users\雨初\AppData\Roaming\Typora\typora-user-images\image-20210515151405744.png)
+ `CONTAINING_RECORD` 可以根据结构体类型和结构体中成员变量地址和名称求出该变量所在结构体的指针

#### 练习：创建一个10个结点的链表并打印

```cpp
#include <ntddk.h>

// 函数声明
NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING RegPath);
VOID DriverUnload(PDRIVER_OBJECT pDriver);

PDRIVER_OBJECT g_driver = NULL;

typedef struct
{
	ULONG data;
	LIST_ENTRY listEntry;
}MYDATA;

typedef MYDATA* PMYDATA; 

VOID test()
{
	LIST_ENTRY listHead;
	InitializeListHead(&listHead);
	for (int i = 0; i < 10; i++)
	{
		PMYDATA t = (PMYDATA)ExAllocatePool(PagedPool, sizeof(MYDATA));
		t->data = i;
		InsertHeadList(&listHead, &t->listEntry); // 这里第二个参数一定要传listentry指针
	}

	while (!IsListEmpty(&listHead))
	{
		PLIST_ENTRY t = RemoveHeadList(&listHead);
		PMYDATA pdata = (PMYDATA)CONTAINING_RECORD(t, MYDATA, listEntry);
		DbgPrint("%d\n", pdata->data);
		ExFreePool(pdata);
	}
}

// 入口函数
NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING RegPath)
{
	g_driver = pDriver;
	test();
	// 设置卸载函数
	pDriver->DriverUnload = DriverUnload;
	return STATUS_SUCCESS;
}

// 卸载驱动
VOID DriverUnload(PDRIVER_OBJECT pDriver)
{
	DbgPrint("驱动卸载成功\n");
}
```

### 4-3快查表

+ 

#### 代码

```cpp
VOID test()
{
	PAGED_LOOKASIDE_LIST lookAsideList;
	ExInitializePagedLookasideList(&lookAsideList, NULL, NULL, 0, sizeof(MYDATA), 'abcd', 0);

	PMYDATA pdata[100] = { NULL };

	for (int i = 0; i < 100; i++)
	{
		// 从快查表中申请
		pdata[i] = (PMYDATA)ExAllocateFromPagedLookasideList(&lookAsideList);
		pdata[i]->data = i;
	}
	 
	for (int i = 0; i < 100; i++)
	{
		DbgPrint("%d\n", pdata[i]->data);
        // 从快查表中删除
		ExFreeToPagedLookasideList(&lookAsideList, pdata[i]);
	}
	
    // 删除快查表
	ExDeletePagedLookasideList(&lookAsideList);
}
```

### 4-4

+ 如果想用 `C++` 来写驱动， `DriverEntry` 前面要加上 `extern "C"` 。在驱动编译的时候 `new` 和 `delete` 是不存在的，需要自己进行重载运算符自己写 `new` 和 `delete` 的逻辑。