![image-20201015114700763](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201015114700763.png)

+ `ctrl + alt + T` 打开终端

+ 在磁盘中以节视图来存储，在内存中以段视图来存储

  ![image-20201017180134934](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201017180134934.png)

+ 载入到内存之后只管段就可以，因为在内存中节是不被需要的。

+ 在 `linux` 里面低3G是用户空间，高2G是内核空间。注意和 `windows` 下的低2G用户，高2G内核区分。

  ![image-20201017182840400](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201017182840400.png)

+ 在32位的进程中每一段都是有用到的，但是在64位的进程中可以看到在 `kernel space` 下面有一段 `undefined region` ，这一段空间是没有被使用的。

  ![image-20201017185052128](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201017185052128.png)

+ BSS段是全局变量，初始化的时候没有东西。（未初始化的全局变量）（只有装载到内存中后才会占用空间，在ELF文件中时不占用空间。）

+ DATA段也是全局变量，不过存放的是已初始化的全局变量。

+ 小端序低地址存放数据低位、高地址存放数据高位

  ![image-20201017190315997](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201017190315997.png)

+ 栈从高地址向低地址生长

+ `LEAVE` 等效于

  1. MOV ESP, EBP

  2. POP EBP

+ **INTEL** 汇编格式和 **AT&T** 汇编格式最大的区别就是**其操作数和指令的位置是反过来的。** ，另其取值符号也不一样， `intel` 是中括号，而 `AT&T` 是小括号。

  ![image-20201017192435445](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201017192435445.png)

+ 压栈的时候参数是反向压入的。 `f(1, 2, 3)` 在栈帧中实际形态如下

  ![image-20201017195518586](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201017195518586.png)

+ IDA里面白色的函数是已经编译在程序里面的函数，而粉色的函数是要在动态链接库里面找的函数。

+ 要让IDA展示硬编码可以这样设置

  ![image-20201017203736293](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201017203736293.png)

+ 选择 `copy to disassembly` 就可以将C语言的代码拷贝到汇编代码中，可以对照汇编代码来看C语言代码，如下

  ![image-20201017203945650](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201017203945650.png)

  ![image-20201017204005726](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201017204005726.png)

+ 找不到main函数可以先 `shift + f12` 找字符串再找main函数

+ pwntools要连接本地的程序可以 `io.process("./ret2text")` 这样

  ![image-20201017212120529](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201017212120529.png)

+ 使用 `io.send()` 的时候

+ `sendline` 和  `send` 的区别就是后面加上了一个 `\n`

+ `setbuf(stdin, 0)` 和 `setbuf(stdout, 0)` 用来关闭缓冲区（想一下之前混音的时候要用 `fflush` 将缓冲区的东西刷新出去），这个是用来方便出题人的，对于做题人没什么帮助。

+ pwntools获取shellcode的硬编码

  ![image-20201017231744771](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201017231744771.png)

  如果要获得64位的shellcode则要

  ![image-20201017231920731](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201017231920731.png)

+ 要设置成这样才会识别你在打一个64位的程序

  ![image-20201017232105739](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201017232105739.png)
  
+ IDA中的值可能会错误，所以遇到一个题一定要 `pwndbg` 动态调试一下看看到底需要多少垃圾数据。

+ `.ljust()` 可以左对齐数据，左边的数据不变，右边的数据一直填充到满足要求的字节数。这样可以在 `shellcode` 后面填充相应的字节数，然后让这一段数据正好足够溢出。

+ `ctrl + shift + c` 可以复制，所有相应的快捷键都加上 `shift` 才能使用。

+ 虽然64位程序的空间有8个字节，但是用户空间的地址只会用6个字节。

+ `ldd a.out` 可以查看 `a.out` 所用到的所有动态链接库

  ![image-20201018113031673](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201018113031673.png)

+ `ret2syscall` 中 `eax, ebx, ecx, edx` 分别存储四个参数

  ![image-20201018115111130](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201018115111130.png)

+ **第一个栈帧是main函数的栈帧** ，之前的引导程序都是没有栈帧的（大部分都是用汇编写的程序，没有栈帧）。

+ `ROPgadget --binary 文件 --only "pop|ret"` 在这个文件中寻找只含有 `pop` 和 `ret` 的代码。

+ 所需要的 `gadget` 最重要的是后面是 `ret` ，因为这样我们就可以不断地让程序跳转到下一个 `gadget` 来达到我们的目的。

+ 计算需要填充多少个字节才能覆盖到EBP的时候要看实际这个字符串被放到了哪里，ESP上面的是指向这个字符串的指针，如下

  ![image-20201018170537209](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201018170537209.png)

  实际要溢出的数量是 `0xd188 - 0xd11c = 0x6c` 

+ 用 `payload = flat([参数， 参数， 参数 ... ])` 可以将所有参数整理为字节流

+ 如果看到一个静态链接的文件，说明这个文件比较容易找 `gadget` 。因为库函数都静态编译到文件里面了。

+ `.got` 表就是 `global offset table` ，全局偏移量表。

+ `PLT ` 全称是程序链接表（ **Procedure Linkage Table** ）

+ `plt` 表在代码段，每一个 `plt` 表项的长度都是 `0x10` 个字节。

+ 第一次调用之前， `got` 表中的地址是其对应函数的 `plt` 表的 `jmp` 指令的下一行地址，

  ![image-20201019104346059](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201019104346059.png)

  转到 `plt0` 然后转到 `*(got + 8)` 调用 `__dl_runtime_resolve` 函数解析出 `foo` 的真实地址并填入到 `.got.plt` 中，即此时其对应的 `plt` 表中的地址已经被改为 `foo` 函数当前真实的地址了，第二次调用这个函数的时候通过 `jmp *(foo@got)` 就可以直接跳转到内核空间对应的函数的地址进行函数的调用而不需要再一次获取这个函数的地址。









## gdb

+ `n` 可以步过（next）， `s` 为步进（step in）。
+ `stack n` 可以查看 `n` 项stack
+ `vmmap` 可以查看 `virtual memory map` ，即虚拟内存的空间分布。
+ 在gdb里面看到的栈的地址是不可靠的，和实际运行的栈的位置并不一定一样。
+ 在gdb中默认 `ASLR` 是关闭的。
+ 输入 `plt` 可以查看 `plt` 表里面的内容
+ 输入 `x 内存地址` 可以查看某段内存里面存的东西。 `x/大小 内存地址` 可以查看指定大小的内存的值。
+ `disass 目标地址` 可以将目标地址的内容反汇编并展示  