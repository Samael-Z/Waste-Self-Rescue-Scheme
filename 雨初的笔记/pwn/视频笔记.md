![image-20201015114700763](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201015114700763.png)

+ `ctrl + alt + T` 打开终端

+ 在磁盘中以节视图来存储，在内存中以段视图来存储

  ![image-20201017180134934](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201017180134934.png)

+ 载入到内存之后只管段就可以，因为在内存中节是不被需要的。

+ 在 `linux` 里面低3G是用户空间，高2G是内核空间。注意和 `windows` 下的低2G用户，高2G内核区分。

  ![image-20201017182840400](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201017182840400.png)

+ 在32位的进程中每一段都是有用到的，但是在64位的进程中可以看到在 `kernel space` 下面有一段 `undefined region` ，这一段空间是没有被使用的。

  ![image-20201017185052128](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201017185052128.png)

+ BSS段是全局变量，初始化的时候没有东西。（未初始化的全局变量）（只有装载到内存中后才会占用空间，在ELF文件中时不占用空间。）

+ DATA段也是全局变量，不过存放的是已初始化的全局变量。

+ 小端序低地址存放数据低位、高地址存放数据高位

  ![image-20201017190315997](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201017190315997.png)

+ 栈从高地址向低地址生长

+ `LEAVE` 等效于

  1. MOV ESP, EBP

  2. POP EBP

+ **INTEL** 汇编格式和 **AT&T** 汇编格式最大的区别就是**其操作数和指令的位置是反过来的。** ，另其取值符号也不一样， `intel` 是中括号，而 `AT&T` 是小括号。

  ![image-20201017192435445](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201017192435445.png)

+ 压栈的时候参数是反向压入的。 `f(1, 2, 3)` 在栈帧中实际形态如下

  ![image-20201017195518586](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201017195518586.png)

+ IDA里面白色的函数是已经编译在程序里面的函数，而粉色的函数是要在动态链接库里面找的函数。

+ 要让IDA展示硬编码可以这样设置

  ![image-20201017203736293](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201017203736293.png)

+ 选择 `copy to disassembly` 就可以将C语言的代码拷贝到汇编代码中，可以对照汇编代码来看C语言代码，如下

  ![image-20201017203945650](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201017203945650.png)

  ![image-20201017204005726](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201017204005726.png)

+ 找不到main函数可以先 `shift + f12` 找字符串再找main函数

+ pwntools要连接本地的程序可以 `io.process("./ret2text")` 这样

  ![image-20201017212120529](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201017212120529.png)

+ 使用 `io.send()` 的时候

+ `sendline` 和  `send` 的区别就是后面加上了一个 `\n`

+ `setbuf(stdin, 0)` 和 `setbuf(stdout, 0)` 用来关闭缓冲区（想一下之前混音的时候要用 `fflush` 将缓冲区的东西刷新出去），这个是用来方便出题人的，对于做题人没什么帮助。

+ pwntools获取shellcode的硬编码

  ![image-20201017231744771](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201017231744771.png)

  如果要获得64位的shellcode则要

  ![image-20201017231920731](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201017231920731.png)

+ 要设置成这样才会识别你在打一个64位的程序

  ![image-20201017232105739](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201017232105739.png)
  
+ IDA中的值可能会错误，所以遇到一个题一定要 `pwndbg` 动态调试一下看看到底需要多少垃圾数据。

+ `.ljust()` 可以左对齐数据，左边的数据不变，右边的数据一直填充到满足要求的字节数。这样可以在 `shellcode` 后面填充相应的字节数，然后让这一段数据正好足够溢出。

+ `ctrl + shift + c` 可以复制，所有相应的快捷键都加上 `shift` 才能使用。

+ 虽然64位程序的空间有8个字节，但是用户空间的地址只会用6个字节。

+ `ldd a.out` 可以查看 `a.out` 所用到的所有动态链接库

  ![image-20201018113031673](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201018113031673.png)

+ `ret2syscall` 中 `eax, ebx, ecx, edx` 分别存储四个参数

  ![image-20201018115111130](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201018115111130.png)

+ **第一个栈帧是main函数的栈帧** ，之前的引导程序都是没有栈帧的（大部分都是用汇编写的程序，没有栈帧）。

+ `ROPgadget --binary 文件 --only "pop|ret"` 在这个文件中寻找只含有 `pop` 和 `ret` 的代码。

+ 所需要的 `gadget` 最重要的是后面是 `ret` ，因为这样我们就可以不断地让程序跳转到下一个 `gadget` 来达到我们的目的。

+ 计算需要填充多少个字节才能覆盖到EBP的时候要看实际这个字符串被放到了哪里，ESP上面的是指向这个字符串的指针，如下

  ![image-20201018170537209](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201018170537209.png)

  实际要溢出的数量是 `0xd188 - 0xd11c = 0x6c` 

+ 用 `payload = flat([参数， 参数， 参数 ... ])` 可以将所有参数整理为字节流

+ 如果看到一个静态链接的文件，说明这个文件比较容易找 `gadget` 。因为库函数都静态编译到文件里面了。

+ `.got` 表就是 `global offset table` ，全局偏移量表。

+ `PLT ` 全称是程序链接表（ **Procedure Linkage Table** ）

+ `plt` 表在代码段，每一个 `plt` 表项的长度都是 `0x10` 个字节。

+ 第一次调用之前， `got` 表中的地址是其对应函数的 `plt` 表的 `jmp` 指令的下一行地址，

  ![image-20201019104346059](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201019104346059.png)

  转到 `plt0` 然后转到 `*(got + 8)` 调用 `__dl_runtime_resolve` 函数解析出 `foo` 的真实地址并填入到 `.got.plt` 中，即此时其对应的 `plt` 表中的地址已经被改为 `foo` 函数当前真实的地址了，第二次调用这个函数的时候通过 `jmp *(foo@got)` 就可以直接跳转到内核空间对应的函数的地址进行函数的调用而不需要再一次获取这个函数的地址。

+ 记小端序这样记：**小的地址放低位**

  ![image-20201017190315997](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201017190315997.png)

  像这样， `0x0d` 是低位，放在 `a` （地址最小的位置）。

+ `elf.got["函数名"]` 可以获取相应函数的 **got表项的地址** 。

  ![image-20201019163039988](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201019163039988.png)

+ 关闭 `ASLR` 的命令

  ![image-20201019163945845](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201019163945845.png)

  ```bash
  echo 0 > /proc/sys/kernel/randomize_va_space
  ```

  

+ `more` 的时候 **+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 ** 可以搜索字符串。

+ 标准输入是 `0` ，标准输出是 `1` ，标准错误是 `2` 。

+ 本地只能用来看偏移量，不能用来看地址，各种地址都要通过泄露获得。

+ 所给的 `libc` 文件是用来获得 `system` 和某个特定函数的偏移的。 

+ 虽然开了 `ASLR` 之后每次获取的地址都不太一样，但是其 **后三位** 很可能是一样的，因为段页机制。

+ 在 `libc` 中找 `system` 的位置要用

  ```python3
  libc = ELF("libc位置")
  libc.symbols["system"]
  ```

+ `libc` 在 `/usr/lib32` 文件夹里面

+ `system("sh")` 也能获得shell，那么如果使用这样的字符串，也同样能获取shell。比如这里，就有一个 `sh\0x00` 的字符串，就可以利用来获取 `shell` 而不用再通过ROP来调用 `gets` 往 `bss` 段里面写 `/bin/sh` 。

  ![image-20201020205848495](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201020205848495.png)
  
+ x86传递参数是用栈来传递，而65位程序前6个参数都是通过寄存器来传递，到了第七个参数才通过栈来传递

  ![image-20201021090433976](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201021090433976.png)
  
+ `ldd 程序名` 可以显示其链接到的 `libc` 的地址。

  ![image-20201021165950970](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201021165950970.png)

  得到的是一个软链接，`file` 一下可以得到实际地址

  ![image-20201021170531210](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201021170531210.png)

  （这个软链接链接到的是其当前路径下的 `libc-2.28.so` ）

+ 这样的一行代码就是放置 `canary` 的代码。

  ![image-20201021181748826](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201021181748826.png)

+ `canary`  并不一定放在 `ebp` 上面，具体放在哪里取决于编译器。

## 栈迁移

+ 首先要可以覆盖到 `prev ebp` 的地址，然后在执行 `leave` 的时候就会将 `ebp` 迁移到另外的地方，比如 `bss` 段。然后如果能再找到一段 `gadget` 可以修改 `esp` 的值如 `pop esp ret` 或者 `mov esp, ebp` ，就可以将整个栈迁移到我们需要的位置。这种方法可以在溢出的数据不足以构造 `ROP` 的时候使用。

+ `debug` 版的程序可能使用 `ebp` 寻址，但是题目中使用的 `release` 版程序多使用 `esp` 寻址，因此我们主要需要做的是控制 `esp` 。首先控制 `ebp` 的目的也是之后能够控制 `esp` ，只有控制了 `esp` 才好干活。

+ 我觉得劫持了 `ebp` 之后可以通过 `leave ret` 的 `gadget` 来修改 `esp` 的值。

+ 在高版本的 `libc` 中，触发 `canary` 之后不会显示出程序的名字，所以 `smashes` 那道题所利用的漏洞被修复了

  ![image-20201021193947274](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201021193947274.png)

  `smashes` 这道题就是一直往下将原来存储的这个程序的名字的地址也更改了，最后触发 `canary` 的时候就会将 `flag` 输出（报错的时候输出）。但是在高版本的 `libc` 中不再输出这个字符串了，那个地址存储的值也变成了 `0x0` ，所以这个程序在本地是打不通的

  ![image-20201021194717727](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201021194717727.png)

+ 64位的 `level3` 的栈的布置如下

  ![image-20201021195545502](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201021195545502.png)

  这道题没有能够控制 `rdx` 的 `gadget` ，不过因为 `write` 第三个参数是向屏幕写入多少个字符，所以可以寄希望于原来 `rdx` 的值大于8（泄露libc），这道题是可以做到的。 



## 格式化字符串

+ `printf("%100$d")` 就是取第100个元素。 `%数字$d` 就是强制取第 `数字` 个元素来作为参数。
+ `%hn` 可以只写2个字节， `%hhn` 可以只写一个字节。
+ 只要 `printf` 第一个参数可以被我们控制，那么就可以做到往内存中任意位置写入数据以及读取数据。





## pwntools

+ `.recvuntil()` 中的 `drop` 参数用来判断是否保留until的那个字符串，如果 `drop = True` 则不保留， `drop = False` 则保留。

  ![image-20201020211047128](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201020211047128.png)

+ `success` 可以用来打印，用来debug（为啥不用print呢？）

  ![image-20201020211524433](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201020211524433.png)

+ `cyclic(数字)` 可以生成指定数量的垃圾数据

  ![image-20201020211810784](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201020211810784.png)

  而且这样写出来的垃圾数据每5个字节为一组，从 `aaaab` 到 `aaaac` 一直往后。这样可以方便调试。
  
+ `io.recv(4)` 可以指定只接收4个字节的数据。

+ `io.recvline()` 会将后面的 `\n` 换行符也一起读进来。切割的时候要注意。

+ https://xz.aliyun.com/t/3944

+ http://docs.pwntools.com/en/stable/index.html

+ `p32()` 是 `pack` ，即打包的意思。 `u32()` 是 `unpack` ，即解包的意思。

+ 打开调试输出

  ![image-20201021205410034](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201021205410034.png)

+ ![image-20201021211610273](https://cdn.jsdelivr.net/gh/smallzhong/picgo-pic-bed/image-20201021211610273.png)



## gdb

+ `n` 可以步过（next）， `s` 为步进（step in）。
+ `stack n` 可以查看 `n` 项stack
+ `vmmap` 可以查看 `virtual memory map` ，即虚拟内存的空间分布。
+ 在gdb里面看到的栈的地址是不可靠的，和实际运行的栈的位置并不一定一样。
+ 在gdb中默认 `ASLR` 是关闭的。
+ 输入 `plt` 可以查看 `plt` 表里面的内容，输入 `got` 可以查看 `got` 表里面的内容。
+ 输入 `x 内存地址` 可以查看某段内存里面存的东西。 `x/大小 内存地址` 可以查看指定大小的内存的值。
+ `disass 目标地址` 可以将目标地址的内容反汇编并展示
+ 查看断点信息 `info b`
+ 删除断点 `d 1` 删除1号断点
+ `b main` 在 `main` 函数加断点， `b *地址` 在特定地址下断点， `b 行号` 在C语言代码中的某一行下断点（要加了 `-g`  有调试信息的程序才可以）
+ `c` 是 `contiune` ，继续执行程序，如果下面没有断点就会一直走到程序结束，而如果下面还有断点则会断在下一个断点的位置。   
+ `start` 指令：如果能找到 `main` 函数就可以停在 `main` 函数的第一行，而如果不能找到则会停在程序的入口函数的第一行。
+ `backtrace` 可以查看函数调用栈的祖孙关系
+ `return` 可以执行完当前函数然后跳出当前函数回到上一个调用这个函数的函数处。
+ 用gdb调试程序时，如果想查看寄存器的值，可以使用 `i registers `命令（ `i` 是 `info` 命令缩写）
+ `search` 可以寻找程序的内存中的数据。