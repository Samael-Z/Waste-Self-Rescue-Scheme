+ `tracer` 有什么用

+ ```python
  def product(x, *aaa):
      res = x
      if aaa == None:
          return res
      for i in aaa:
          res *= i
  
      return res
  ```

+ python字符串好像不能改变内容？？？？

```python
# coding:utf-8
import threading
import time
import pickle
import json
import os
import hmac

d = {'user': {'yuchu': 1}}
g_filePath = 'f:\\userdata.txt'
g_userData = {}
g_logintype = ''
g_bookPath = 'f:\\books.txt'
g_bookinfo = {}


def hmac_md5(key, s):
    return hmac.new(key.encode('utf-8'),
                    s.encode('utf-8'), 'MD5').hexdigest()


class LoginError(ValueError):
    pass


class FileError(ValueError):
    pass


def init():
    if not os.path.exists(g_filePath):
        # TODO: 改成X
        with open(g_filePath, 'wb') as fp:
            print('检测到您第一次使用本系统，已为您自动创建配置文件')
            pickle.dump({'admin': {'admin': hmac_md5('admin', 'admin')}}, fp)  # 将管理员用户密码保存到文件中

        return

    if not os.path.exists(g_bookPath):
        with open(g_bookPath, 'wb') as fp:
            books = {'c#入门到精通': 5, '半小时精通c++': 3, 'mysql调优': 6}
            pickle.dump(books, fp)
    with open(g_filePath, 'rb') as fp:
        global g_userData  # 获取全局变量
        g_userData = pickle.load(fp)


if __name__ == '__main__':
    # global g_userData
    init()
    while 1:
        t = input('管理员登录请输入1，用户登录请输入2，用户注册请输入3，退出请输入4:')
        if t == '1':
            usr = input('请输入管理员用户名')
            pwd = input('请输入管理员密码')
            if usr not in g_userData['admin']:
                raise LoginError('此管理员用户名不存在!')

            if g_userData['admin'][usr] == hmac_md5(pwd, usr):
                g_logintype = 'admin'
                print('登录成功')
                break
            else:
                print('登录失败，请重试')
                continue

        elif t == '2':
            usr = input('请输入用户名')

            if 'users' not in g_userData:  # 防止找不到键值
                g_userData['users'] = {}

            if usr not in g_userData['users']:
                raise LoginError('%s用户不存在!' % usr)

            pwd = input('请输入密码')

            if g_userData['users'][usr] == hmac_md5(pwd, usr):
                g_logintype = 'user'
                print('欢迎您，%s' % usr)
                break

        elif t == '3':
            usr = input('请输入您要注册的账号')
            if 'users' in g_userData and (usr in g_userData['users']):
                print('此账号已被注册，请重试')
                continue

            pwd = input('请输入您的密码')

            if 'users' not in g_userData:  # 如果没有这个键
                g_userData['users'] = {}

            g_userData['users'][usr] = hmac_md5(usr, pwd)
            with open(g_filePath, 'wb') as f:
                pickle.dump(g_userData, f)
            print('注册成功！请登录！')

    # 登录注册操作完成，以下为借书操作
    if g_logintype == 'admin':

        if not os.path.exists(g_bookPath):
            raise PathError('存书文件不存在！')

        with open(g_bookPath, 'rb') as fp:
            g_bookinfo = pickle.load(fp)

        while 1:
            t = input('请输入您想进行的操作，1.查看库存所有图书 2.新增书籍 3.修改书籍的数量 4.退出')
            if t == '1':
                for key, value in g_bookinfo.items():
                    print(f'{key}共有{value}本')

            elif t == '2':
                b = input('请输入您想要入库的书籍：')
                if b in g_bookinfo:
                    print('您想要入库的书籍已经在库中了！')
                    continue
                else:
                    ct = input('请输入您想要入库的书籍数量：')
                    g_bookinfo[b] = ct
                    with open(g_bookPath, 'wb') as fp:
                        pickle.dump(g_bookinfo, fp)
                    print(f'成功入库{ct}本{b}！')

            elif t == '3':
                b = input('请输入您想要修改数量的书籍:')
                if b not in g_bookinfo:
                    print('库存中没有这本书！请先进行入库操作！')
                    continue
                else:
                    print(f'此书现在共有{g_bookinfo[b]}本', end='')
                    ct = input('请输入您想要修改的数量:')
                    g_bookinfo[b] = ct
                    with open(g_bookinfo, 'wb') as fp:
                        pickle.dump(g_bookinfo, fp)
                    print('修改成功！')

    elif g_logintype == 'user':
        # TODO: 以后这里要换成如果不存在就自动创建文件
        if not os.path.exists(g_bookPath):
            raise PathError('存书文件不存在！')

        with open(g_bookPath, 'rb') as fp:
            g_bookinfo = pickle.load(fp)

        while 1:
            t = input('请输入您想进行的操作，1.查看库存所有图书 2.借书 3.还书 4.退出')
            if t == '1':
                for key, value in g_bookinfo.items():
                    print(f'{key}共有{value}本')

            elif t == '2':
                borrow = input('请输入您想要借的书名')
                if borrow not in g_bookinfo:
                    print('抱歉没有找到这本书')
                    continue
                else:
                    g_bookinfo[borrow] -= 1
                    with open(g_bookPath, 'wb') as fp:  # 保存
                        pickle.dump(g_bookinfo, fp)
                    print('借书成功！祝您生活愉快~')

            elif t == '3':
                # TODO: 还书功能
                b = input('请输入您要还的书名')
                if b not in g_bookinfo:
                    print('此书不存在！')
                    continue
                else:
                    g_bookinfo[b] += 1
                    with open(g_bookinfo, 'wb') as fp:
                        pickle.dump(g_bookinfo, fp)
                    print(f'还书成功！现在{b}的库存为{g_bookinfo[b]}')


            elif t == '4':
                break

    else:
        raise ValueError('g_logintype值错误！')

    print(g_userData)

```

```python
def bs(a):
    l = len(a)
    for i in range(l):
        for j in range(l - i - 1):
            if a[j] > a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]


def ss(a):
    l = len(a)
    for i in range(l):
        m = i
        for j in range(i, l):
            if a[m] > a[j]:
                m = j
        a[m], a[i] = a[i], a[m]


def qs(a):
    if len(a) < 2:
        return a

    t = a[0]
    a.remove(t)
    left, right = [], []
    for i in a:
        if i < t:
            left.append(i)
        else:
            right.append(i)
    return qs(left) + [t] + qs(right)


def aa(a):
    l = len(a)
    for i in range(1, l):
        t = a[i]
        j = i - 1
        while j >= 0 and a[j] > t:
            a[j + 1] = a[j]
            a[j] = t
            j -= 1


```

