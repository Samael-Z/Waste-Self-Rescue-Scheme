+ e_lfanew中存的是NT头 **相对文件头** 的偏移

+ `SizeOfImage` 整个PE映像装入内存中后的总大小，必须是内存对齐的倍数, `sizeofImage/SectionAllignment == 0` 才可以

  ![](https://raw.githubusercontent.com/smallzhong/picgo-pic-bed/master/20200706170603.png)

+ 节表中的各个参数的意义

  ![](https://raw.githubusercontent.com/smallzhong/picgo-pic-bed/master/20200706173659.png)
  + `SizeOfRawData` 是这个节在进行对齐之后的长度（这个节在文件中的真实大小）

  + `VirtualAddress` 是这个节装载到内存中之后的偏移（该块的 **RVA** ）

    > **RVA是** 相对虚拟地址（Relative Virtual Address）的缩写

  + `PointerToRawData` 是这个节的地址在 **拉伸之前** 在文件中的偏移

+ ![](https://raw.githubusercontent.com/smallzhong/picgo-pic-bed/master/20200706175900.png)

+ 软件设计中要 **高内聚，低耦合** ，即一个模块做的工作应该尽可能单一，多个模块之前的联系应该尽可能小

+ 如果要改变 `SizeOfHeaders` ，那么后面的所有代码里面的 `CALL` `jmp` 之类的指令后面跟的地址都要改变。全局变量也会受到影响。代价太大。一般不要想着去动这个东西。

+ 要添加一个节表的话要起码保证添加之前节表中最后一个节的末尾离节开始的地方起码要能再放下两个节表（ **0x56个字节** ），因为最后一个节表的位置离节起码还要空下一个节表的位置。

  ![](https://raw.githubusercontent.com/smallzhong/picgo-pic-bed/master/20200707155042.png)

  如图。在具体计算的时候要用 **SizeOfHeader** 减去 **DOS头 + NT头 + (0x28 * NumberOfSections)** 的大小，判断是否大于 **0x56个字节**

+ 如果想要添加一个节，必须修改的东西如下

  ![](https://raw.githubusercontent.com/smallzhong/picgo-pic-bed/master/20200707155805.png)	

+ 如果像notepad.exe这样在节表后面有一段有意义的数据，不确定是否能删除的话

  ![](https://raw.githubusercontent.com/smallzhong/picgo-pic-bed/master/20200707163628.png)

  可以尝试把节表往上拉。因为 **DOS头** 和 **NT头** 之间有一段垃圾数据。只要在往上拉了之后将 **DOS头** 中的 **e_lfanew（DOS头的大小为0x30，e_lfanew是DOS头最后的一个 `LONG` 大小的数据）** 进行更改，便可以正常运行。拉完之后节表后便多出了空白区域，可以自己添加节表了。

  + 在节表最后要留出一个节表的位置并全置为0。如果不留，运行时并不一定会出现问题，但是并不能保证永远不出问题。最好还是要留出一个节表大小的0比较稳妥。

+ 这样获得的指针如果修改了里面的元素其实也会修改 `pFileBuffer` 里面的东西

  ![](https://raw.githubusercontent.com/smallzhong/picgo-pic-bed/master/20200707204406.png)

+ 海哥的教案中关于节表中的数据的描述

  ![](https://raw.githubusercontent.com/smallzhong/picgo-pic-bed/master/20200708111112.png)
  
+ 可以用 `#pragma comment(lib, "xxx.lib")` 来包含一个静态链接库，或者也可以

  ![](https://raw.githubusercontent.com/smallzhong/picgo-pic-bed/master/20200708161428.png)

  点开 **settings** ，在 **link** 中加上需要添加的静态链接库

  ![image-20200708161809490](C:\Users\雨初\AppData\Roaming\Typora\typora-user-images\image-20200708161809490.png)

  + 我们常用的printf、memcpy、strcpy等就来自这种静态库
  + 静态链接库的缺点：使用静态链接生成的可执行文件体积较大，造成浪费
  + 如果改了静态链接库，每次都要重新编译一遍，但是如果是用动态链接库的话就可以“头疼医头，脚疼医脚”，不用修改原来的程序

+ 在OD中点这个 **E** 可以看到程序里面有多少个模块

  ![](https://raw.githubusercontent.com/smallzhong/picgo-pic-bed/master/20200708162359.png)

+ ![](https://raw.githubusercontent.com/smallzhong/picgo-pic-bed/master/20200708165923.png)

  这些都是无符号整型（ **unsigned int** ）（四个字节，一个 **DWORD** 的大小）

+ 新增一个 `.def` 文件

  ![](https://raw.githubusercontent.com/smallzhong/picgo-pic-bed/master/20200708171135.png)
  
+ 并不是说EXE就没有导出表，EXE也能提供函数，也可能有导出表。比如ollydbg就有导出表。

+ 导出表中三张表里面的成员个数并不一定是一样的，因为可能会有无名函数，无名函数就没有 `AddressOfNames` 

  ![](https://raw.githubusercontent.com/smallzhong/picgo-pic-bed/master/20200708225511.png)

+  要获取一个 `LPVOID` 指向的地址所通过 `malloc,calloc` 等方法获取的堆空间的大小，可以用微软提供的 `_msize` 函数。具体使用方法为 `size_t _msize(void *memblock);`   <https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/msize?view=vs-2019>

+ 地址表并不一定比名字表大，可以让不同名字都指向同一个地址。

+ 序号表和名字表的大小是一样的，都是 `NumberOfNames` 的值

  ![](https://raw.githubusercontent.com/smallzhong/picgo-pic-bed/master/20200709115309.png)

+ 序号表里面的值加上 `Base` 才是真正的导出序号

  ![](https://raw.githubusercontent.com/smallzhong/picgo-pic-bed/master/20200709115450.png)

+ 导出函数的查找方式

  1. 名字导出

     如果要找一个相应名字的导出函数的地址，要遍历 `AddressOfNames` 表（表内存的是存储其名字的地址的 `RVA` ，要先把 `RVA` 转换为 `FOA` 才能找到其在文件中的地址）找到与需要找的函数名对应的函数是第n个，然后在 **序号表** 中找到第n个序号对应是几，然后再在 **函数地址表** 中找到对应序号的函数

  ![](https://raw.githubusercontent.com/smallzhong/picgo-pic-bed/master/20200709120338.png)

   2. 序号导出

      得到序号，减去 `Base（导出函数起始序号）` 的值，直接到 `AddressOfFunctions` 表中找相应值的函数地址。 **完全不需要使用**  `AddressOfNameOrdinals` 和 `AddressOfNames` 两张表

  

+ 写两个函数，能够大概达到系统提供的 `GetProcAddress` 函数的效果 

  ![](https://raw.githubusercontent.com/smallzhong/picgo-pic-bed/master/20200709122300.png)

+ 在重定位表中，存放的是需要修改的地址。一个节里面只有 **0x1000** 个地址，所以 **2^12** 就够了，即12个二进制数。但是要对齐。所以每一小块是16个bit。 只看低12位。把低12位所代表的数字加上 `VirtualAddress` 即可得到真正需要修改的位置。高四位的值如果是 `0011` ，说明这个地方需要修改，如果不是 `0011` ，说明不需要修改这个位置。

+ 看重定位表的时候先判断 **高四位** ，如果是 `0011` 的话就说明后面存的地址需要修改，如果不是 `0011` 的话就说明后面存的地址不用修改。

+ 重定位表结束的地方其 `VirtualAddress` 和 `SizeOfBlock` 都是0，表示重定位表结束。

+  `SizeOfBlock` 中存储的是整一块的大小

  ![](https://raw.githubusercontent.com/smallzhong/picgo-pic-bed/master/20200710095744.png)

  如果需要得到这一块中存了多少个地址，就用 `SizeOfBlock` 减去 **8（前两个结构的大小）** 再除以2 **一个地址信息是2字节宽的，也就是一个WORD**  


+ 重定位表中的 `Size` 属性并没有什么用，删掉之后并不影响运行。重定位表的大小可以通过找到最后一个表（里面的内容都是0的表）来决定。

+ 节表中 `Characteristics` 属性

  ![](https://raw.githubusercontent.com/smallzhong/picgo-pic-bed/master/20200711152753.png)
  
+ 重定位表中 `VirtualAddress` 加上存的地址即为需要改的地址的 `RVA` 

+ `RVA` 是内存中相对于基地址 `ImageBase` 的偏移

+ <https://www.52pojie.cn/forum.php?mod=viewthread&tid=1128322&highlight=%D6%D8%B6%A8%CE%BB%B1%ED>

  重定位表在实际应用中的使用：把重定位表中存的所有 `RVA` 里面存放的数据按照如下方式进行修正。重定位表里面只是存放了需要修改的地址，其里面的值并不会在修改的时候参与运算

  ![](https://raw.githubusercontent.com/smallzhong/picgo-pic-bed/master/20200712172932.png)

+ 导入表

  
    + **INT表** ：导入名称表（ **Improt Name Table** ）
    
    + **IAT表** ：导入地址表（ **Import Address Table** ）
    
  + INT表和IAT表在程序加载之前都是一样的，存的都是函数的名，但是加载后IAT表中存的是通过（GetProcAddr）得到的地址。之所以要用两张表的原因是不仅要存放地址，还要存放函数的名字
  
  + 对于 `IMAGE_THUNK_DATA` 来说，如果最高位是 **1** ，那么除去最高位的值就是函数的导出序号。如果不是，那么这个值是一个 **RVA** ，指向 `IMAGE_IMPORT_BY_NAME` 。
  
    ![](https://raw.githubusercontent.com/smallzhong/picgo-pic-bed/master/20200713103111.png)
  
+ `PIMAGE_THUNK_DATA32` 和 `PIMAGE_THUNK_DATA64` 的区别是后者里面存储的数据都是 `unsigned long long（8字节）` ，前者都是 `unsigned int（4字节）`

+ 如果 `IMAGE_THUNK_DATA` 的最高位为1，说明其除去最高位的值就是函数的导出序号。如果不是，说明这个值是一个 `RVA` ，指向 `IMAGE_IMPORT_BY_NAME` 。

+ 导入表

  + 如果导入表还没和输入的DLL进行绑定，其里面 `TimeDateStamp` （时间戳）的值为0

  ![](https://raw.githubusercontent.com/smallzhong/picgo-pic-bed/master/20200714094803.png)

  + 如果导入表已经绑定（如notepad.exe），其里面 `TimeDateStamp` 为 **-1（即0xffffffff）** 。

+ 当 `IMAGE_BOUND_IMPORT_DESCRIPTOR` 结构中的 `TimeDateStamp` 与DLL文件标准PE头中的 `TimeDateStamp` 值不相符时，或者DLL需要重新定位的时候，就会重新计算IAT中的值。

+ 绑定导入表中 `IMAGE_BOUND_IMPORT_DESCRIPTOR` 和 `IMAGE_BOUND_FORWARDER_REF` 这两个结构的大小完全一样。

  ![](https://raw.githubusercontent.com/smallzhong/picgo-pic-bed/master/20200714152255.png)

+ ![](https://raw.githubusercontent.com/smallzhong/picgo-pic-bed/master/20200714164450.png)

  + 在dll中， `DllMain` 里面的东西是在往4GB空间里面贴的时候调用一次，在从4GB空间里面拿出来的时候再调用一次。

  + 调用dll的时候，如果是 `#pragma comment(lib,"DLL名.lib")` 像这样隐式链接，那么在程序加载的时候会调用 `init` ，且只有程序退出的时候才会调用 `destroy` 函数。但是如果是像这样动态加载的话

    ![](https://raw.githubusercontent.com/smallzhong/picgo-pic-bed/master/20200714164125.png)

    可以随时加载以及随时销毁（移出4GB空间）

+ INT表可以动，但是 **IAT** 表不能动。否则exe里面 `CALL` 的时候会找不到原来的地方。

+ `DWORD`  = `DWORD32` ，都是4字节的， `DWORD64` 是8字节的

+ `DataDirectory` 里面的 `Size` 在改动了导入表大小之后一定要修改。不然会挂。

+ `this` 指针指向的是当前结构的首地址。

    ```cpp
    void getAddr()
    {
        return *(int*)this; 
    }
    ```

    可以获得当前结构的首地址
    
+ `call` 后面跟一个地址叫做直接调用，如 `call ...` ，而 `call` 后面跟了一个表达式叫做间接调用。如 `call [...]` 。反映到硬编码上，前一种是 `E8 XXXX(添加SHELLCODE的时候用的就是这种)` ，后一种是 `FF XXXX`

+ `new` 创建的对象分配在堆区里面， `Base base` 这样创建的局部变量放在栈里面，全局变量放在专门放全局变量的那个节里面。

+ 通过指针去调用一个虚函数 (`virtual`) ，其生成的汇编代码中是 `FF` call。

+ 只要类里面有虚函数，其大小就会多出 **4个字节** 。而且无论有多少个虚函数都只多 **4个字节**  。

+ 如果类里面有虚函数，则其有虚表。这个类在内存中的第一个元素就是这个虚表的地址（？），如图

    ![image-20200721112721976](C:\Users\雨初\AppData\Roaming\Typora\typora-user-images\image-20200721112721976.png)

     而如果没有这个虚函数，则第一个元素是类中第一个成员。

    + 这个第一个元素存储的地址指向一个数组，数组里面存了这个类里面所有虚函数的地址。

      ![](https://raw.githubusercontent.com/smallzhong/picgo-pic-bed/master/20200721113752.png)

    + 总结一下就是如果一个类里面有虚函数，那么这个类的 `this` 指针（指向类里面的第一个元素）所指向的是这个类对应的 **虚函数表的地址** 。这个虚函数表是一个 `DWORD` 的数组，里面存储的是所有虚函数的地址。类里面不是 `virtual` 的函数的地址直接就是死的，只有 `virtual` 虚函数需要通过虚函数表来访问。

    + 如果有一个 **直接父类** ，则多 **4个** 字节（有一个 **虚函数表** ），而如果有n个 **直接父类** ，则多 **4 * n** 个字节（有n个 **虚函数表** ）

+ 重载 **overload** 和重写 **override** 是不一样的，重写是覆盖，函数名一样，参数一样，返回值一样。覆盖了这个函数。这叫重写 **(override)** 。而重载( **overload** )只是函数名一样，其他不一定一样。

+ 多重继承时，虚函数覆盖了哪个，就在哪个表里面。基类覆盖了A父类的函数，那么这个覆盖后的函数的地址就在A的那个表里面，覆盖了B父类的函数就在B的那个虚表里面。